<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Creshendo</name>
    </assembly>
    <members>
        <member name="T:Creshendo.Functions.TrueFunction">
            <author>  Nikolaus Koemm
            
            Min returns the smallest of two or more values.
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.IFunction">
            <author>  Peter Lin
            *
            Function is the base interface for all functions. We probably should move
            this to another package later on. For now, I Put it here.
            The design of Function is very similar to Methods, since a function is
            basically a stand alone method.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.IFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> Functions must implement concrete logic for the function.
            To execute a function, 2 parameters are needed. The first
            is the rule engine, which is needed to resolve global variables,
            and other engine activities like asserts. The second is an
            array of parameters, which can be bindings, literal values or
            other functions.
            It is the responsibility of the programmer to iterate over the
            parameters to find the data they need to execute the function.
            </summary>
            <param name="">engine
            </param>
            <param name="">params
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Functions.IFunction.toPPString(Creshendo.Util.Rete.IParameter[],System.Int32)">
            <summary> A convienance method to Get a pretty printer formatted string
            for the function.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Functions.IFunction.ReturnType">
            <summary> every function needs to declare what the return type is.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Functions.IFunction.Name">
            <summary> Every function must declare the name
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Functions.IFunction.Parameter">
            <summary> Functions should declare what kind of parameters it takes.
            If a function doesn't take any parameters, the method should return
            null.
            For example, set-member function returns 
            BoundParam.class,StringParam.class,ValueParam.class. This means
            the first parameter is a binding, the second is a slotname and the
            third is the value.
            Another example is Add function. It returns ValueParam[].class, since
            it can take one or more numbers and Add them.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Functions.TrueFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.TemplateValidation">
            <summary> Template validation will check the templates of the rule and make
            sure they are valid. If it isn't, validate(Rule) will return false
            and provide details.
            
            </summary>
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.IAnalysis.analyze(Creshendo.Util.Rule.IRule)">
            <summary> If the rule passes validation, it should return true. If the rule
            was not valid for any reason, return false.
            </summary>
            <param name="">rule
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.TemplateValidation.#ctor(Creshendo.Util.Rete.Rete)">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.SetMembertFunction">
            <author>  Peter Lin
            *
            SetMemberFunction is equivalent to JESS set-member function. This is a completely
            clean implementation from scratch. The name and function signature are similar,
            but the design and implementation are different. The design of the function is
            strongly influenced by CLIPS, since the primary goal is full CLIPS compatability.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.SetMembertFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.SetMembertFunction.Parameter">
            <summary> The current implementation expects 3 parameters in the following
            sequence:<br/>
            BoundParam
            StringParam
            ValueParam
            <br/>
            Example: (set-member ?objectVariable slotName value)
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NoMemOr">
            <author>  Peter Lin
            *
            AlphaNodeMS is similar to AlphaNode. The main difference is AlphaNode2
            is for comparing a slot against multiple values with equal/not equal
            operator.
            <br/>
            Although there is a class called Alpha memory, Alpha nodes use a
            simple org.jamocha.rete.util.IList to remember which facts matched. A decision was made to
            use a simple org.jamocha.rete.util.List, since assert only takes a single Fact object.
            If we change assert to take an array of facts, we would need to
            replace the List with a map of AlphaMemory.<br/>
            
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.BaseAlpha2">
            <author>  Peter Lin
            
            BaseAlpha2 is an abstract class for AlphaNodes that compare literal or bound
            constraints. It isn't used for LIANode, ObjectTypeNode.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.BaseAlpha">
            <author>  Peter Lin
            
            BaseAlpha is the baseAlpha node for all 1-input nodes.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.BaseNode">
            <author>  Peter Lin
            *
            BaseNode is meant to define common logic that all nodes must have
            and implement common logic.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IPrettyPrint.toPPString">
            <summary> Return a pretty print formatted String.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="F:Creshendo.Util.Rete.BaseNode.successorNodes">
            <summary> We use an object Array to keep things efficient
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BaseNode.useCount">
            <summary> The useCount is used to keep track of how many times
            an Alpha node is shared. This is needed so that we
            can dynamically Remove a rule at run time and Remove
            the node from the network. If we didn't keep count,
            it would be harder to figure out if we can Remove the node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.#ctor(System.Int32)">
            <summary>
            BaseNode has only one constructor which takes an unique
            node id. All subclasses need to call the constructor.
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.toPPString">
            <summary>
            toPPString should return a string format, but formatted
            nicely so it's easier for humans to read. Chances are
            this method will be used in debugging mode, so the more
            descriptive the string is, the easier it is to figure out
            what the node does.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.containsNode(System.Object[],System.Object)">
            <summary>
            Determines whether the specified list contains node.
            </summary>
            <param name="list">The list.</param>
            <param name="node">The node.</param>
            <returns>
            	<c>true</c> if the specified list contains node; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.addNode(Creshendo.Util.Rete.BaseNode)">
            <summary>
            Add the node to the list of successors
            </summary>
            <param name="n">The n.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.removeNode(Creshendo.Util.Rete.BaseNode)">
            <summary>
            Remove the node from the succesors
            </summary>
            <param name="n">The n.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.addSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Adds the successor node.
            </summary>
            <param name="node">The node.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.removeAllSuccessors">
            <summary>
            Method is used to decompose the network and make sure
            the nodes are detached from each other
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Subclasses need to implement Clear and make sure all
            memories are cleared properly.
            </summary>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.incrementUseCount">
            <summary>
            every time the node is shared, the method
            needs to be called so we keep an accurate count.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.decrementUseCount">
            <summary>
            every time a rule is removed from the network
            we need to decrement the count. Once the count
            reaches zero, we can Remove the node by calling
            it's finalize.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.ToString">
            <summary>
            toString should return a string format of the node and
            the pattern it matches.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseNode.hashString">
            <summary>
            hashString should return a string which can be used as
            a key for HashMap or HashTable
            </summary>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BaseNode.SuccessorNodes">
            <summary>
            Returns the successor nodes
            </summary>
            <value>The successor nodes.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.BaseNode.NodeId">
            <summary>
            Return the node id
            </summary>
            <value>The node id.</value>
            <returns>
            </returns>
        </member>
        <member name="F:Creshendo.Util.Rete.BaseAlpha.operator_Renamed">
            <summary> The operator to compare two values
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Alpha nodes must implement this method
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Alpha nodes must implement this method. Retract should Remove
            a fact from the node and propogate through the RETE network.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.propogateRetract(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> method for propogating the retract
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.propogateAssert(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Method is used to pass a fact to the successor nodes
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.addSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Set the Current node in the sequence of 1-input nodes.
            The Current node can be an AlphaNode or a LIANode.
            </summary>
            <param name="">node
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.removeSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Remove a successor node
            </summary>
            <param name="">node
            </param>
            <param name="">engine
            </param>
            <param name="">mem
            @throws AssertException
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.getMemory(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Get the list of facts that have matched the node
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            implementation simply Clear the List
            </summary>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.hashString">
            <summary> Subclasses need to implement this method. The hash string
            should be the slotId + operator + value
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.toPPString">
            <summary> subclasses need to implement PrettyPrintString and print
            out user friendly representation fo the node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.ToString">
            <summary> subclasses need to implement the toString and return a textual
            form representation of the node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha.removeAllSuccessors">
            <summary> Method is used to decompose the network and make sure
            the nodes are detached from each other.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.BaseAlpha.Operator">
            <summary> Abstract implementation returns an int code for the
            operator. To Get the string representation, it should
            be converted.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseAlpha2.#ctor(System.Int32)">
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.BaseAlpha2.Operator">
            <summary> set the operator type for the node
            </summary>
            <param name="">opr
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.BaseAlpha2.Slot">
            <summary> set the slot for the node
            </summary>
            <param name="">sl
            
            </param>
        </member>
        <member name="F:Creshendo.Util.Rete.NoMemOr.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.NoMemOr.useCount">
            <summary> The useCount is used to keep track of how many times
            an Alpha node is shared. This is needed so that we
            can dynamically Remove a rule at run time and Remove
            the node from the network. If we didn't keep count,
            it would be harder to figure out if we can Remove the node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.incrementUseCount">
            <summary> every time the node is shared, the method
            needs to be called so we keep an accurate count.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.decrementUseCount">
            <summary> every time a rule is removed from the network
            we need to decrement the count. Once the count
            reaches zero, we can Remove the node by calling
            it's finalize.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation will first check to see if the fact already matched.
            If it did, the fact stops and doesn't go any further. If it doesn't,
            it will attempt to evaluate it and Add the fact if it matches.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract a fact from the node
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.evaluate(Creshendo.Util.Rete.IFact)">
            <summary> evaluate the node's value against the slot's value. The method
            uses Evaluate class to perform the evaluation
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.hashString">
            <summary> method returns toString() for the hash
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.ToString">
            <summary> Method returns the string format of the node's condition. later on
            this should be cleaned up.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemOr.toPPString">
            <summary> Method returns the pretty printer formatted string of the node's
            condition. For now, the method just replaces the operator. It might
            be nice to replace the slot id with the slot name.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemOr.Shared">
            <summary> the first time the RETE compiler makes the node shared,
            it needs to increment the useCount.
            </summary>
            <param name="">share
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemOr.Slot">
            <summary> Set the slot id. The slot id is the deftemplate slot id
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemOr.UseCount">
            <summary> return the times the node is shared
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemOr.Operator">
            <summary> method is not implemented, since it doesn't apply
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Min">
            <author>  Nikolaus Koemm
            
            Min returns the smallest of two or more values.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Min.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.LoadFactsFunction">
            <author>  Peter Lin
            LoadFunction will create a new instance of CLIPSParser and load the
            facts in the data file.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.LoadFactsFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.IFunctionGroup">
            <author>  Peter Lin
            *
            FunctionGroup is an organizational feature to group functions. For example,
            one might want to group mathematic functions together. Or IO functions together
            into a group.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.IFunctionGroup.loadFunctions(Creshendo.Util.Rete.Rete)">
            <summary> classes implementing the interface need to implement this method to
            create instances of the function and register them the rule engine.
            </summary>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Functions.IFunctionGroup.listFunctions">
            <summary> A convienance method for listing the functions in a given group.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.FactsFunction">
            <author>  Peter Lin
            
            Facts function will printout all the facts, not including any
            initial facts which are internal to the rule engine.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.FactsFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.EngineEvent">
            <author>  Peter Lin
            *
            EngineEvent is a generic event class. Rather than have a bunch of
            event subclasses, the current design uses event type code.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.EngineEvent.typeCode">
            <summary> the default value is assert event
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EngineEvent.#ctor(System.Object,System.Int32,Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.IFact[])">
            <summary> 
            </summary>
            <param name="source">- the source should be either the workingMemory or Rete
            </param>
            <param name="typeCode">- event type
            </param>
            <param name="sourceNode">- the node which initiated the event
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Rule.IComplexity">
            <author>  Peter Lin
            *
            Complexity is a basic interface for rule complexity. The complexity 
            could be calculated when the rule is compiled, or dynamically at runtime.
            There are a couple reasons why dynamic 
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rule.BoundConstraint">
            <author>  Peter Lin
            *
            BoundConstraint is a basic implementation of Constraint interface
            for bound constraints. When a rule declares a slot as a binding,
            a BoundConstraint is used.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rule.IConstraint">
            <author>  Peter Lin
            *
            Constraints come in 3 varieties:
            1. value constraint where an object's field is compared to a value
            2. variable constraint where a field is bound to a variable
            3. predicate constraint where the field is bound to a variable, and
            then evaluated against 1 or more operations.
            
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.IConstraint.toPPString">
            <summary> A convienance method to return pretty print format.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.IConstraint.Name">
            <summary> This should be the name of the constraint. In the case of an
            object, it is the field's name
            </summary>
            <returns>
            
            </returns>
            <summary> Set the name of the constraint.
            </summary>
            <param name="">name
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IConstraint.Value">
            <summary> The value of the constraint. Primitive numeric types are
            wrapped in the object version. Example, int is wrapped in
            Integer.
            </summary>
            <returns>
            
            </returns>
            <summary> Set the value of the constraint. In the case of a binding,
            the value is the variable name
            </summary>
            <param name="">val
            
            </param>
        </member>
        <member name="F:Creshendo.Util.Rule.BoundConstraint.isMultislot_Renamed_Field">
            <summary> if the binding is for a multislot, it should be
            set to true. by default, it is false.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.BoundConstraint.name">
            <summary> the name is the slot name
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.BoundConstraint.value_Renamed">
            <summary> In the case of BoundConstraints, the value is the name of
            the variable given my the user
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.BoundConstraint.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.BoundConstraint.toPPString">
            <summary> returns the constriant in a pretty printer format
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.BoundConstraint.firstDeclaration">
            <summary> by default the method returns false, unless it is set to true
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.BoundConstraint.IsObjectBinding">
            <summary> if the binding is to an object or deffact, the method will
            return true.
            </summary>
            <returns>
            
            </returns>
            <summary> Set the constraint to true if the binding is for an object or
            a deffact.
            </summary>
            <param name="">obj
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.BoundConstraint.Multislot">
            <summary> if the binding is for a multislot, it will return true.
            by default is is false.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.BoundConstraint.IsMultislot">
            <summary> only set the multislot to true if the slot is defined
            as a multislot
            </summary>
            <param name="">multi
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.BoundConstraint.Negated">
            <summary> if the literal constraint is negated, the method returns true
            </summary>
            <returns>
            
            </returns>
            <summary> if the literal constraint is negated with a "~" tilda, call
            the method pass true.
            </summary>
            <param name="">negate
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.BoundConstraint.Name">
            <summary> The name of the slot or object field.
            </summary>
            <summary> the name is the name of the slot or object field.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.BoundConstraint.Value">
            <summary> The value is the name of the variable. In the case of CLIPS,
            if the rule as "?name", the value returned is "name" without
            the question mark prefix.
            </summary>
            
            <summary> The input parameter should be a string and it should be
            the name of the variable. Make sure to parse out the
            prefix. For example, CLIPS uses "?" to denote a variable.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.IAlphaMemory">
            <author>  Peter Lin
            *
            Interface for alpha memory. Alpha memories are used to remember
            which facts entered and match for alpha nodes.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IAlphaMemory.addPartialMatch(Creshendo.Util.Rete.IFact)">
            <summary>
            Add a partial match to the memory
            </summary>
            <param name="fact">The fact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IAlphaMemory.clear">
            <summary>
            Clear the alpha memory for the node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IAlphaMemory.removePartialMatch(Creshendo.Util.Rete.IFact)">
            <summary>
            Remove a partial match from the memory
            </summary>
            <param name="fact">The fact.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IAlphaMemory.size">
            <summary>
            Count returns the number of matches
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IAlphaMemory.GetEnumerator">
            <summary>
            Return an GetEnumerator to iterate over the matches.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Creshendo.Functions.Math.Add">
            <author>  Peter Lin
            
            Add will Add one or more numbers and return the result.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Add.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Parser.Clips2.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Parser.Clips2.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            </summary>
            <remarks>
            You can explicitly create objects of this exception type by
            calling the method GenerateParseException in the generated
            parser.
            <para>
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </para>
            </remarks>
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.ParseException.#ctor(Creshendo.Util.Parser.Clips2.Token,System.Int32[][],System.String[])">
            This constructor is used by the method "GenerateParseException"
            in the generated parser. Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.  The boolean
            flag "specialConstructor" is also set to true to indicate that
            this constructor was used to create this object.
            This constructor calls its super class with the empty string
            to force the "toString" method of parent class "Throwable" to
            print the error message in the form:
                ParseException: 
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.ParseException.#ctor">
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.ParseException.specialConstructor">
            This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.ParseException.currentToken">
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.ParseException.expectedTokenSequences">
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.ParseException.tokenImage">
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.ParseException.eol">
            The end of line string for this machine.
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.ParseException.AddEscapes(System.String)">
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
        </member>
        <member name="P:Creshendo.Util.Parser.Clips2.ParseException.Message">
            This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
        </member>
        <member name="T:Creshendo.Functions.Math.Abs">
            <author>  Nikolaus Koemm, Christian Ebert
            
            Returns the absolute value of a double value.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Abs.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.TemplatesFunction">
            <author>  Peter Lin
            
            The purpose of the function is to print out the names of the rules
            and the comment.
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.StringIndexFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringIndexFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.RulesFunction">
            <author>  Peter Lin
            
            The purpose of the function is to print out the names of the rules
            and the comment.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.PredicateBNode">
            <author>  Peter Lin
            
            HashedBetaNode indexes the right input to improve cross product performance.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.BaseJoin">
            <author>  Peter Lin
            *
            BaseJoin is the abstract base for all join node classes.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.BaseJoin.binds">
            <summary> binding for the join
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.BaseJoin"/> class.
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Subclasses must implement this method. assertLeft takes
            inputs from left input adapter nodes and join nodes.
            </summary>
            <param name="lfacts">The lfacts.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Subclasses must implement this method. assertRight takes
            input from alpha nodes.
            </summary>
            <param name="rfact">The rfact.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Subclasses must implement this method. retractLeft takes
            input from left input adapter nodes and join nodes.
            </summary>
            <param name="lfacts">The lfacts.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Subclasses must implement this method. retractRight takes
            input from alpha nodes.
            </summary>
            <param name="rfact">The rfact.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.addSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Adds the successor node.
            </summary>
            <param name="node">The node.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.addSuccessorNode(Creshendo.Util.Rete.BaseJoin,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            When new Successor nodes are added, we propogate the facts that matched to
            the new join node.
            </summary>
            <param name="node">The node.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.addSuccessorNode(Creshendo.Util.Rete.TerminalNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            it's unlikely 2 rules are identical, except for the name. The implementation
            gets the current memory and propogates, but I wonder how much sense this
            makes in a real production environment. An user really shouldn't be deploying
            identical rules with different rule name.
            </summary>
            <param name="node">The node.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.removeAllSuccessors">
            <summary>
            Method is used to decompose the network and make sure
            the nodes are detached from each other.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.propogateAssert(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Method is used to pass a fact to the successor nodes
            </summary>
            <param name="inx">The inx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BaseJoin.propogateRetract(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            method for propogating the retract
            </summary>
            <param name="inx">The inx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="P:Creshendo.Util.Rete.BaseJoin.Bindings">
            <summary>
            Set the bindings for this join
            </summary>
            <value>The bindings.</value>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be joining
            against one or more objects, we need to pass all previously matched
            facts.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an Alpha node.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left requires that we propogate the
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order. 1. Remove the fact
            from the right memory 2. check which left memory matched 3. propogate the
            retract
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete)">
            <summary> Method will use the right binding to perform the evaluation of the join.
            Since we are building joins similar to how CLIPS and other rule engines
            handle it, it means 95% of the time the right fact list only has 1 fact.
            
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.ToString">
            <summary> Basic implementation will return string format of the betaNode
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.PredicateBNode.toPPString">
            <summary> returns the node named + node id and the bindings in a string format
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.PredicateBNode.Bindings">
            <summary> Set the bindings for this join
            
            </summary>
            <param name="">binds
            
            </param>
        </member>
        <member name="F:Creshendo.Util.Messagerouter.InterestType.ALL">
            <summary> used for channels which are interested in every message output,
            regardless which channel caused this output.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Messagerouter.InterestType.MINE">
            <summary> used for channels which are only interested in the message output, which
            is in response for their to their own input.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Messagerouter.InterestType.NONE">
            <summary> used for channels which aren't interested in any message output.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.GetMembertFunction">
            <author>  Peter Lin
            *
            SetMemberFunction is equivalent to JESS set-member function. This is a completely
            clean implementation from scratch. The name and function signature are similar,
            but the design and implementation are different. The design of the function is
            strongly influenced by CLIPS, since the primary goal is full CLIPS compatability.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.GetMembertFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.GetMembertFunction.getMethodReturnType(System.Reflection.MethodInfo)">
            <summary> For now, this utility method is here, but maybe I should move it
            to some place else later.
            </summary>
            <param name="">m
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Functions.GetMembertFunction.ReturnType">
            <summary> By default, the function returns Object type. Since the function
            can be used to call any number of getXXX methods and we wrap
            all primitives in their object equivalent, returning Object type
            makes the most sense.
            </summary>
        </member>
        <member name="P:Creshendo.Functions.GetMembertFunction.Parameter">
            <summary> The current implementation expects 3 parameters in the following
            sequence:<br/>
            BoundParam - the bound object
            StringParam - the slot name
            ValueParam - the value to set the field
            <br/>
            Example: (set-member ?objectVariable slotName value)
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.FunctionAction">
            <author>  Peter Lin
            *
            A FunctionAction is responsible for executing a function in the action
            of the rule. It uses built-in or user written functions. When the rule
            is loaded, the engine looks up the functions. At run time, the rule
            simply executes it.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IAction">
            <author>  Peter Lin
            *
            Actions constitute the Right-hand side of a rule. In RULEML terms,
            the Right-hand side is the head. The Action interface is meant to
            define the methods necessary to execute rules which match fully.
            An action will typically contain several functions. It's the job
            of the action to contain the functions and make it easier to
            execute.
            Part of the responsibility of the action is to know how to Get
            the a fact or binding.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IAction.configure(Creshendo.Util.Rete.Rete,Creshendo.Util.Rule.IRule)">
            <summary> The purpose of configure is to setup the action when the rule
            is loaded to the rule engine. When the parser parses the rule,
            it may not lookup the functions. That will be the common case,
            which means when the rule is added to the rule engine, the
            lookup needs to occur.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IAction.executeAction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IFact[])">
            <summary> When an action is executed, we pass the facts and the Rete
            instance.
            </summary>
            <param name="">engine
            </param>
            <param name="">facts
            @throws ExecuteException
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IAction.toPPString">
            <summary> return a pretty printer format for the action
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.FunctionAction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.FunctionAction.configure(Creshendo.Util.Rete.Rete,Creshendo.Util.Rule.IRule)">
            <summary> Configure will lookup the function and set it
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.FunctionAction.toPPString">
            <summary> method implements the necessary logic to print out the action
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Floor">
            <author>  Nikolaus Koemm
            
            Floor returns the greatest integer smaller or equal to a value.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Floor.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.EventCounter">
            <author>  Peter Lin
            *
            EventCounter is a simple utility class for counting and keeping track 
            of events. It can be used for various purposes like keeping track of
            statistics or unit tests.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.EngineEventListener">
            <author>  Peter Lin
            *
            Classes that listen for various engine related events should implement
            the interface and handle the events appropriately.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.EventCounter.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.EventCounter.addNodeFilter(Creshendo.Util.Rete.BaseNode)">
            <summary> To listen to a specific node, Add the node to the filter
            </summary>
            <param name="">node
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.DeffunctionGroup">
            <author>  pete
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.DeffunctionGroup.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.DeffunctionGroup.loadFunctions(Creshendo.Util.Rete.Rete)">
            <summary> At engine initialization time, the function group doesn't
            have any functions.
            </summary>
        </member>
        <member name="M:Creshendo.Functions.DeffunctionGroup.addFunction(Creshendo.Functions.IFunction)">
            <summary> Add a function to the group
            </summary>
            <param name="">f
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.DeffunctionFunction">
            <summary> DeffunctionFunction is used for functions that are declared in the
            shell. It is different than a function written in java.
            Deffunction run interpreted and are mapped to existing
            functions.
            
            </summary>
            <author>  Peter Lin
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.DeffunctionFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Constants">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.ADD">
            --------- operators types ---------///
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.ADD_STRING">
            --------- operators strings ---------///
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.ADD_SYMBOL">
            --------- operators symbol ---------///
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.FORWARD_CHAINING">
            ----------- constants for chaining direction -------///
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.INT_PRIM_TYPE">
            --------- primitive types ---------///
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.OBJECT_TYPE">
            --------- non-primitive types ---------///
        </member>
        <member name="F:Creshendo.Util.Rete.Constants.SLOT_TYPE">
            --------- native types for the rule engine ---------///
        </member>
        <member name="T:Creshendo.Functions.BatchFunction">
            <author>  Peter Lin
            *
            Functional equivalent of (batch file.clp) in CLIPS and JESS.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.BatchFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.BatchFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> method will attempt to load one or more files. If batch is called without
            any parameters, the function does nothing and just returns.
            </summary>
        </member>
        <member name="M:Creshendo.Functions.BatchFunction.parse(Creshendo.Util.Rete.Rete,System.IO.Stream,Creshendo.Util.Rete.DefaultReturnVector)">
            <summary>
            method does the actual work of creating a CLIPSParser and parsing
            the file.
            </summary>
            <param name="engine">The engine.</param>
            <param name="ins">The ins.</param>
            <param name="rv">The rv.</param>
        </member>
        <member name="T:Creshendo.Functions.Math.Atan">
            <author>  Christian Ebert
            
            Returns the trigonometric arc tangent of an angle.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Atan.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.AbstractTemporalNode">
            <author>  Peter Lin
            
            AbstractTemporalNode is the base class for all temporal joins. For performance
            reasons, we will have several subclasses.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractTemporalNode.leftElapsedTime">
            <summary> The relative elapsed time for the left side of the join.
            The default value is 0 to indicate it has no time window
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractTemporalNode.rightElapsedTime">
            <summary> the relative elapsed time for the right side of the join
            The default value is 0 to indicate it has no time window
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be joining
            against one or more objects, we need to pass all previously matched
            facts.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an Alpha node.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left requires that we propogate the
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order. 1. Remove the fact
            from the right memory 2. check which left memory matched 3. propogate the
            retract
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact,System.Int64)">
            <summary> evaluate will first compare the timestamp of the last fact in the fact
            array of the left and make sure the fact is still fresh. if it is not
            fresh, the method returns false.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.ToString">
            <summary> Basic implementation will return string format of the betaNode
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractTemporalNode.toPPString">
            <summary> returns the node named + node id and the bindings in a string format
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.AbstractActivationList">
            <author>  Peter Lin
            *
            This is a base class the defines the common fields like lazy and
            strategy for the activation list. Creating new activationList
            implementations should extend this class.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IActivationList">
            <author>  Peter Lin
            *
            ActivationList defines the basic operations for an activation list. This
            makes it easier to experiment with different ways of implementing an
            activation list. The potential methods are queue, priorityQueue, stack
            and linkedlist.
            Since I haven't decided on the approach, using an interface will allow me
            to replace the implementation later on. Rather than guess, my plan is to
            implement different versions and benchmark them. This way, I can use the
            one that works the better.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivationList.nextActivation">
            <summary> Depending on whether lazy is set or not, the activation list may
            assume the activations are ordered by priority and should just
            return the first or last activation. in the case where the agenda
            is lazy, it will need to compare the evaluations.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivationList.addActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Add a new activation to the list
            </summary>
            <param name="">act
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivationList.removeActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Remove a given activation from the list
            </summary>
            <param name="">act
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivationList.clear">
            <summary> In order for strategies to prioritize the activations, we have
            to expose the underlying list.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivationList.size">
            <summary> number of activation in the list
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivationList.cloneActivationList">
            <summary> sometimes we need to clone the list, so that users can see what is
            in the activation list or print it out.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IActivationList.Lazy">
            <summary> In some cases, if most of the activations will be removed, it makes
            sense to do lazy comparison. This means that any strategy could
            potentially work lazily
            </summary>
            <returns>
            
            </returns>
            <summary> If an activation list is lazy, it will delay the compare until
            nextActivation is called.
            </summary>
            <param name="">lazy
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.IActivationList.Strategy">
            <summary> return the current strategy
            </summary>
            <returns>
            
            </returns>
            <summary> set the strategy for the activation list
            </summary>
            <param name="">strat
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.Math.Tan">
            <author>  Christian Ebert
            
            Returns the trigonometric tangent of an angle.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Tan.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.SubStringFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.SubStringFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ResetFactsFunction">
            <author>  Peter Lin
            *
            TODO To change the template for this generated type comment go to
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ResetFactsFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.ResetFactsFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> current implementation will call Rete.resetAll. This means it
            will reset all objects and deffacts.
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ResetFactsFunction.ReturnType">
            <summary> the function does not return anything
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ResetFactsFunction.Parameter">
            <summary> reset does not take any parameters
            </summary>
        </member>
        <member name="T:Creshendo.Util.ProfileStats">
            <author>  Peter Lin
            *
            ProfileStats is used to collect statistics about the runtime.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.startFire">
            <summary> method should be called when Rete.fire is called or simply
            turn on profiling in Rete.
            </summary>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.endFire">
            <summary> endFire will automatically calculate the elapsed time
            and Add it to the total fire time. if the start fire 
            timestamp is zero, the elapsed time will not be
            calculated.
            </summary>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.addFireET(System.Int64)">
            <summary> Add a long time to the total fire time
            </summary>
            <param name="">time
            
            </param>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.startAssert">
            <summary> method should be called before assert is called or turn
            profiling in Rete.
            </summary>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.endAssert">
            <summary> method will automatically calculate the elapsed time and
            Add it to the total assert time. if the start assert
            timestamp is zero, elpased time will not be calculated
            and added.
            </summary>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.addAssertET(System.Int64)">
            <summary> Add elapsted time to assert total time
            </summary>
            <param name="">time
            
            </param>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.startRetract">
            <summary> the method should be called before retract is called or
            turn of profiling in the Rete class.
            </summary>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.endRetract">
            <summary> method will calculate the elapsed time and Add it to the
            total retract time. if the start retract timestamp is zero
            the elapsed time will not be calculated.
            </summary>
        </member>
        <member name="M:Creshendo.Util.ProfileStats.addRetractET(System.Int64)">
            <summary> Add elapsed time to retract total
            </summary>
            <param name="">time
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ParameterUtils.convertParameters(System.Collections.IList)">
            <summary> The method takes a list containing Parameters and converts it to
            an array of Parameter[]. Do not pass a list with other types
            </summary>
            <param name="">list
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ParameterUtils.slotToParameters(System.Collections.IList)">
            <summary> slotToParameters is a convienant utility method that converts
            a list containing parameters and Slots to an array of Parameter[].
            The method is used by the parser to handle modify statements.
            </summary>
            <param name="">list
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.ObjectTypeNode">
            <author>  Peter Lin
            *
            ObjectTypeNode is the input node for a specific type. The node
            is created with the appropriate Class. A couple of important notes
            about the implementation of ObjectTypeNode.
            
            
            the assertFact method does not check the deftemplate matches
            the fact. this is because of inheritance.
            WorkingMemoryImpl checks to see if the fact's deftemplate
            has parents. If it does, it will keep checking to see if there is
            an ObjectTypeNode for the parent.
            if the template has a parent, it will assert it. this means
             any patterns for parent templates will attempt to pattern
            match
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.ObjectTypeNode.operators">
            <summary> before the operators included not nill, but for it to work properly
            we have to first test the slot is not nill, and then do the hash
            lookup. not sure that it's worth it, so removed it instead.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.ObjectTypeNode.deftemplate">
            <summary> The Class that defines object type
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.ObjectTypeNode.entries">
            <summary> HashMap entries for unique AlphaNodes
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.ObjectTypeNode.gauranteeUnique">
            <summary> If we can gaurantee Uniqueness of the AlphaNodes, set it to true
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.ObjectTypeNode.successor2">
            <summary> Second org.jamocha.rete.util.List for all nodes that do not use ==, null operators
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.#ctor(System.Int32,Creshendo.Util.Rete.ITemplate)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear the memory. for now the method does not
            Remove all the successor nodes. need to think it over a bit.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.clearSuccessors">
            <summary> method to Clear the successors. method doesn't iterate over
            the succesors and Clear them individually.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assert the fact and propogate. ObjectTypeNode does not call
            assertEvent, since it's not that important and doesn't really
            help debugging.
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.assertFactWithMap(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assert using HashMap approach
            
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            </param>
            <param name="">mem
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.assertAllSuccessors(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Propogate the fact using the normal way of iterating over the
            successors and calling assert on AlphaNodes and assertRight on
            BetaNodes.
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            </param>
            <param name="">mem
            @throws AssertException
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract the fact to the succeeding nodes. ObjectTypeNode does not call
            assertEvent, since it's not that important and doesn't really
            help debugging.
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.addSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Add a successor node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.hashString">
            <summary> For the ObjectTypeNode, the method just returns toString
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.ToString">
            <summary> this returns name of the deftemplate
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ObjectTypeNode.toPPString">
            <summary> this returns name of the deftemplate
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.ObjectTypeNode.SuccessorCount">
            <summary> return the number of successor nodes
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Functions.ListFunctionsFunction.toPPString(Creshendo.Util.Rete.IParameter[],System.Int32)">
            <summary> for now, just return the simple form. need to implement the method
            completely.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.HashedNotEqNJoin">
            <author>  Peter Lin
            
            HashedNotEqBNode2 indexes the right input for joins that use
            not equal to. It uses 2 levels of indexing. The first is the bindings
            for equal to, the second is not equal to.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an Alpha node.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left requires that we propogate the
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.ToString">
            <summary> Basic implementation will return string format of the betaNode
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqNJoin.toPPString">
            <summary> returs the node name + id and bindings
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Greater">
            <author>  Peter Lin
            
            Greater will compare 2 or more numeric values and return true if the (n-1)th value
            is greater than the nth.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Greater.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.FalseFunction">
            <author>  Nikolaus Koemm
            
            Min returns the smallest of two or more values.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.FalseFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ExitFunction">
            <author>  Peter Lin
            
            ExitFunction is used to call Rete.close() and then it calls System.exit(0).
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ExitFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ExitFunction.Parameter">
            <summary> the function does not take any parameters. If parameters are passed,
            the function ignores them.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.EvalFunction">
            <author>  Sebastian Reinartz
            
            Functional equivalent of (eval "(+ 1 3)") in CLIPS and JESS.
            
            </author>
        </member>
        <member name="F:Creshendo.Functions.EvalFunction.serialVersionUID">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.EvalFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.EqHashIndex">
            <author>  Peter Lin<p/>
            *
            EqHashIndex is used by the BetaNode for indexing the facts that
            enter from the right.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IHashIndex">
            <summary> The interface has two methods: hashcode and Equals. Both have
            to be implemented, since Sumatra uses HashMaps for indexing and
            for memories.
            </summary>
            <author>  pete
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.EqHashIndex.#ctor(System.Object[])">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EqHashIndex.Equals(System.Object)">
            <summary> The implementation is similar to the index class.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EqHashIndex.GetHashCode">
            <summary> Method simply returns the cached GetHashCode.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EqHashIndex.calculateHash">
            <summary> This is a very simple implementation that gets the slot hash from
            the deffact.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Degrees">
            <author>  Nikolaus Koemm
            
            Degrees converts an angle measured in radians to an approximately equivalent
            angle measured in degrees.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Degrees.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.IConditionCompiler">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 12, 2007 9:32:31 AM
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.IConditionCompiler.compile(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule,System.Boolean)">
            <summary> 
            </summary>
            <param name="">condition
            </param>
            <param name="position">
            </param>
            <param name="">util
            </param>
            <param name="alphaMemory">
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.IConditionCompiler.compileFirstJoin(Creshendo.Util.Rule.ICondition,Creshendo.Util.Rule.IRule)">
            <summary> 
            </summary>
            <param name="">condition
            </param>
            <param name="">rule
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.IConditionCompiler.compileJoin(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule)">
            <summary> 
            </summary>
            <param name="">condition
            </param>
            <param name="">position
            </param>
            <param name="">rule
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.IConditionCompiler.connectJoinNode(Creshendo.Util.Rule.ICondition,Creshendo.Util.Rule.ICondition,Creshendo.Util.Rete.BaseJoin,Creshendo.Util.Rete.BaseJoin)">
            <summary> 
            </summary>
            <param name="">condition
            </param>
            <param name="">joinNode
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.IConditionCompiler.compileSingleCE(Creshendo.Util.Rule.IRule)">
            <summary> compile the only CE in the rule which has only one CE.
            </summary>
            <param name="">rule
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Compiler.IConditionCompiler.RuleCompiler">
            <summary> 
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rule.ICondition">
            <author>  Peter Lin
            *
            Conditions are patterns. It may be a simple fact pattern, test function,
            or an object pattern.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.ICondition.compare(Creshendo.Util.Rule.ICondition)">
            <summary> Method is used to compare the pattern to another pattern and
            determine if they are equal.
            </summary>
            <param name="">cond
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.ICondition.addNode(Creshendo.Util.Rete.BaseNode)">
            <summary> When the rule is compiled, we Add the node to the condition,
            so that we can print out the matches for a given rule.
            </summary>
            <param name="">node
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rule.ICondition.addNewAlphaNodes(Creshendo.Util.Rete.BaseNode)">
            <summary> if the rule's alpha nodes aren't shared, this method is
            used to Add the alphaNodes to the condition
            </summary>
            <param name="">node
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rule.ICondition.clear">
            <summary> Clear the condition
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.ICondition.getCompiler(Creshendo.Util.Rete.IRuleCompiler)">
            <summary> obtain the compiler compile this condition
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.ICondition.Nodes">
            <summary> Get the nodes associated with the condition. In the case of
            TestConditions, it should only be 1 node.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.ICondition.LastNode">
            <summary> Get the last node in the Condition
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.ICondition.BindConstraints">
            <summary> Get the bind Constraint org.jamocha.rete.util.IList including BoundConstraint (isObjectBinding==false) 
            and PredicateConstraint (isPredicateJoin==true)
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.CompositeIndex">
            <author>  Peter Lin
            
            CompositeIndex is used by ObjectTypeNodes to hash AlphaNodes and stick them
            in a HashTable. This should improve the performance over the proof-of-concept
            implementation using Strings.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.CompositeIndex.#ctor(System.String,System.Int32,System.Object)">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.BindFunction">
            <author>  Peter Lin
            
            BindFunction is responsible for calling the appropriate method in Rete to
            create the defglobal.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.BindFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.BindFunction.ReturnType">
            <summary> the return type is Boolean. If the function was successful, it returns
            true. Otherwise it returns false.
            </summary>
        </member>
        <member name="P:Creshendo.Functions.BindFunction.Parameter">
            <summary> The function takes 2 parameters. The first is the name of the variable
            and the second is some value. At the moment, the function does not hand
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Exception.AssertException">
            <author>  Peter Lin
            
            AssertException should be thrown if a node encounters issues matching a fact.
            Normally, this should not occur. If it does, it generally means there's a bug
            in the core RETE nodes.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.AssertException.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.AssertException.#ctor(System.String)">
            <param name="">message
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.AssertException.#ctor(System.String,System.Exception)">
            <param name="">message
            </param>
            <param name="">cause
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.AssertException.#ctor(System.Exception)">
            <param name="">cause
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Rule.AndCondition">
            <author>  Peter Lin
            *
            AndCondition is specifically created to handle and conjunctions. AndConditions
            are compiled to a BetaNode.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.AndCondition.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.AndCondition.addNode(Creshendo.Util.Rete.BaseNode)">
            <summary> the method doesn't apply and isn't implemented currently
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.AndCondition.addNewAlphaNodes(Creshendo.Util.Rete.BaseNode)">
            <summary> not implemented currently
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.TemporalTNode">
            <author>  woolfel
            
            TemporalTNode is the temporal version of TerminalNode. The main difference
            is the node will check the facts. If all facts have not expired, the activation
            gets added to the agenda. If it's expired, the expired facts Get retracted and
            no activation is created.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.TerminalNode2">
            <author>  Peter Lin
            *
            TerminalNode2 is different than TerminalNode in that it uses
            a different Activation implementation. Rather than use BasicActivation,
            it uses LinkedActivation.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.TerminalNode">
            <author>  Peter Lin
            
            Terminal node indicates the rule has matched fully and should execute the
            action of the rule. NOTE: currently this is not used directly. other terminal
            nodes extend it.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.#ctor(System.Int32,Creshendo.Util.Rule.IRule)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.TerminalNode"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="rl">The rl.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            The terminal nodes doesn't have a memory, so the method does nothing.
            </summary>
            <param name="mem"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.assertFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Once the facts propogate to this point, it means all the conditions of
            the rule have been met. The method creates a new Activation and adds it
            to the activationList of the correct module. Note: we may want to change
            the design so that we don't create a new Activation object.
            </summary>
            <param name="facts">The facts.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.retractFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Retract means we need to Remove the activation from the correct module
            agenda.
            </summary>
            <param name="facts">The facts.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.ToString">
            <summary>
            return the name of the rule
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.toPPString">
            <summary>
            return the name of the rule
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode.removeAllSuccessors">
            <summary> The terminal node has no successors, so this method does nothing.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.TerminalNode.Rule">
            <summary>
            Gets the rule.
            </summary>
            <value>The rule.</value>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.#ctor(System.Int32,Creshendo.Util.Rule.IRule)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.TerminalNode2"/> class.
            </summary>
            <param name="id"></param>
            <param name="rl"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            The terminal nodes doesn't have a memory, so the method
            does nothing.
            </summary>
            <param name="mem"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.assertFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Asserts the facts.
            </summary>
            <param name="inx">The inx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.retractFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Retracts the facts.
            </summary>
            <param name="inx">The inx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.removeActivation(Creshendo.Util.Rete.IWorkingMemory,Creshendo.Util.Rete.LinkedActivation)">
            <summary>
            Remove the LinkedActivation from TerminalNode2. This is necessary
            when the activation is fired and the actions executed.
            </summary>
            <param name="mem">The mem.</param>
            <param name="activation">The activation.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.addSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            method does not apply to termial nodes. therefore it's not implemented
            </summary>
            <param name="node">The node.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.ToString">
            <summary>
            return the name of the rule
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode2.toPPString">
            <summary>
            return the name of the rule
            </summary>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.TerminalNode2.Rule">
            <summary>
            Return the Rule object associated with this terminal node
            </summary>
            <value>The rule.</value>
            <returns>
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalTNode.#ctor(System.Int32,Creshendo.Util.Rule.IRule)">
            <param name="">id
            </param>
            <param name="">rl
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalTNode.assertFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Method will call checkFacts() first to make sure none of the facts have
            expired. An activation is only created if the facts are valid.
            </summary>
            <param name="">facts
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalTNode.checkFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> if all the facts have not expired, the method returns true. If a fact has
            expired, the method will retract the fact.
            </summary>
            <param name="">inx
            </param>
            <param name="">engine
            </param>
            <param name="">mem
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.RuleEngineFunctions">
            <author>  Peter Lin
            
            RuleEngineFunction is responsible for loading all the rule functions
            related to engine operation.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.Exception.RetractException">
            <author>  Peter Lin
            *
            TODO To change the template for this generated type comment go to
            Window - Preferences - Java - Code Style - Code Templates
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.RetractException.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.RetractException.#ctor(System.String)">
            <param name="">message
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.RetractException.#ctor(System.String,System.Exception)">
            <param name="">message
            </param>
            <param name="">cause
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.RetractException.#ctor(System.Exception)">
            <param name="">cause
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Rete.Strategies.RecencyStrategy">
            <author>  Peter Lin
            *
            
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IStrategy">
            <author>  Peter Lin
            *
            Strategy defines the basic methods needed to implement conflict
            resolution strategy. In terms of rule engines, Forgy's definition
            of conflict resolution strategy using an agenda is the pre-
            dominant approach used by RETE, TREAT, LEAPS rule engines.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IStrategy.addActivation(Creshendo.Util.Rete.IActivationList,Creshendo.Util.Rete.IActivation)">
            <summary> Strategies that sort activations as they are added to the activation
            list should implement this method. Strategies that prioritize in a
            lazy fashion should implement this method and nextActivation. Lazy
            prioritization will should simply Add the activation to the list.
            </summary>
            <param name="">theModule
            </param>
            <param name="">newActivation
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IStrategy.nextActivation(Creshendo.Util.Rete.IActivationList)">
            <summary> Strategies that implement lazy prioritization need to compare the
            activations in the list and return the correct activation. Strategies
            that aren't lazy should just return the first item in the activation
            list.
            </summary>
            <param name="">theModule
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IStrategy.compare(Creshendo.Util.Rete.IActivation,Creshendo.Util.Rete.IActivation)">
            <summary> Compare 2 activations. The return value is similar to Comparable
            interface.
            -1 less than
            0 equal to
            1 greater than
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.RecencyStrategy.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.RecencyStrategy.addActivation(Creshendo.Util.Rete.IActivationList,Creshendo.Util.Rete.IActivation)">
            <summary> Current implementation will check which order the list is and call
            the appropriate method
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.RecencyStrategy.nextActivation(Creshendo.Util.Rete.IActivationList)">
            <summary> Current implementation will check which order the list is and call
            the appropriate method
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.RecencyStrategy.compare(Creshendo.Util.Rete.IActivation,Creshendo.Util.Rete.IActivation)">
            <summary> The method first compares the salience. If the salience is equal,
            we then compare the aggregate time.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.RecencyStrategy.compareRecency(Creshendo.Util.Rete.IActivation,Creshendo.Util.Rete.IActivation)">
            <summary> compare will look to see which activation has more facts.
            it will first compare the timestamp of the facts. If the facts
            are equal, it will return the activation with more facts.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.MemberTestFunction">
            <author>  Peter Lin
            Any equal is used to compare a literal value against one or more
            bindings. If any of the bindings is equal to the constant value,
            the function returns true.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.MemberTestFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Less">
            <author>  Peter Lin
            *
            Less will compare 2 or more numeric values and return true if the
            (n-1)th value is less than the nth.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Less.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.GreaterOrEqual">
            <author>  Peter Lin
            *
            GreaterOrEqual will compare 2 or more numeric values and return true if the (n-1)th
            value is greater or equal than the nth.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.GreaterOrEqual.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ExistJoin">
            <author>  Peter Lin
            
            ExistJoin is implemented differently than how CLIPS does it. According
            to CLIPS beginners guide, Exist is convert to (not (not (blah) ) ).
            Rather than do that, I'm experimenting with a specialized Existjoin
            node instead. The benefit is reduce memory and fewer nodes in the 
            network. 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an
            Alpha node.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left is different than retractRight for couple
            of reasons.
            <ul>
            <li> NotJoin will only propogate the facts from the left</li>
            <li> NotJoin never needs to merge the left and right</li>
            </ul>
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.ToString">
            <summary> simple implementation for toString. may need to change the format
            later so it looks nicer.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoin.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.ExistCondition">
            <author>  Peter Lin
            *
            ExistCondition for existential quantifier.
            TODO - maybe we should just have ExistCondition extend ObjectCondition
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rule.ObjectCondition">
            <author>  Peter Lin
            *
            ObjectCondition is equivalent to RuleML 0.83 resourceType. ObjectCondition
            matches on the fields of an object. The patterns may be simple value
            comparisons, or joins against other objects.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rule.AbstractCondition.constraints">
            <summary> the constraints for the condition element
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.AbstractCondition.negated">
            <summary> In the case the object pattern is negated, the boolean
            would be set to true.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.AbstractCondition.nodes">
            <summary> a list for the RETE nodes created by RuleCompiler
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.AbstractCondition.template">
            <summary> the deftemplate associated with the ObjectCondition
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.AbstractCondition.templateName">
            <summary> The string template name from the parser, before we
            resolve it to the Template object
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.AbstractCondition.toPPString">
            <summary> Subclasses must implement this method
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.AbstractCondition.Negated">
            <summary> by default patterns are not negated. Negated Conditional Elements
            (aka object patterns) are expensive, so they should be used with 
            care.
            </summary>
            <returns>
            
            </returns>
            <summary> set whether or not the pattern is negated
            </summary>
            <param name="">negate
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.AbstractCondition.BindConstraints">
            <summary> returns the bindings, excluding predicateConstraints
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.ObjectCondition.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.ObjectCondition.compare(Creshendo.Util.Rule.ICondition)">
            <summary> TODO - currently we don't need it and it isn't implemented.
            should finish implementing it.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.ObjectCondition.toPPString">
            <summary> The current implementation expects the deffact or object binding
            constriant to be first.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.ExistCondition.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Exception.ExecuteException">
            <author>  Peter Lin
            *
            ExecuteException is only thrown when the RHS of the rule is executed.
            If the action didn't execute correctly, throw an exception with
            sufficient details to debug the issue.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ExecuteException.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ExecuteException.#ctor(System.String)">
            <param name="">message
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ExecuteException.#ctor(System.String,System.Exception)">
            <param name="">message
            </param>
            <param name="">cause
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ExecuteException.#ctor(System.Exception)">
            <param name="">cause
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.Math.Divide">
            <author>  Peter Lin
            *
            Divide will divide one or more numbers and return a Double value
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Divide.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ConversionUtils">
            <author>  Peter Lin
            *
            ConversioUtils has a methods for autoboxing primitive types
            with the Object equivalent.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.convert(System.Int32)">
            <summary> Convert a int primitive to an Integer object
            </summary>
            <param name="">val
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.convert(System.Int16)">
            <summary> Convert a short primitive to a Short object
            </summary>
            <param name="">val
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.convert(System.Single)">
            <summary> Convert a float primitive to Float object
            </summary>
            <param name="">val
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.convert(System.Int64)">
            <summary> convert a primitive long to Long object
            </summary>
            <param name="">val
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.convert(System.Double)">
            <summary> convert a primitive double to a Double object
            </summary>
            <param name="">val
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.convert(System.SByte)">
            <summary> convert a primitive byte to Byte object
            </summary>
            <param name="">val
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.getPPOperator(System.Int32)">
            <summary> Return the string form of the operator
            </summary>
            <param name="">opr
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.findFact(Creshendo.Util.Rete.Deftemplate,Creshendo.Util.Rete.IFact[])">
            <summary> find the matching fact in the array
            </summary>
            <param name="">temp
            </param>
            <param name="">facts
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.mergeFacts(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact[])">
            <summary> Method will merge the two arrays by Add the facts from
            the right to the end
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.mergeFacts(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> The method will merge a single right fact with the left
            fact array.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.add(Creshendo.Util.Rete.BaseNode[],Creshendo.Util.Rete.BaseNode)">
            <summary> Add a new object to an object array
            </summary>
            <param name="">list
            </param>
            <param name="">nobj
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.remove(Creshendo.Util.Rete.BaseNode[],System.Object)">
            <summary> Remove an object from an object array
            </summary>
            <param name="">list
            </param>
            <param name="">nobj
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.getTypeCode(System.Type)">
            <summary> Return the int mapped type for the field
            </summary>
            <param name="">clzz
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.getTypeName(System.Int32)">
            <summary> Convienance method for converting the int type code
            to the string form
            </summary>
            <param name="">intType
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ConversionUtils.isPredicateOperatorCode(System.String)">
            <summary> If the operate is equal, not equal, greater, less than,
            greater or equal, less than or equal.
            </summary>
            <param name="">strSymbol
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.ClearFunction">
            <author>  Peter Lin
            *
            ClearFunction will call Rete.Clear()
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ClearFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ClearFunction.Parameter">
            <summary> The function does not take any parameters
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.TestNode">
            <author>  Peter Lin
            *
            TestNode extends BaseJoin. TestNode is used to evaluate functions.
            It may use values or bindings as parameters for the functions. The
            left input is where the facts would enter. The right input is a
            dummy input, since no facts actually enter.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.TestNode.func">
            <summary> TestNode can only have 1 top level function
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.TestNode.params_Renamed">
            <summary> the parameters to pass to the function
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.TestNode.ppstring">
            <summary> by default the string is null, until the first time
            toPPString is called.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.#ctor(System.Int32,Creshendo.Functions.IFunction,Creshendo.Util.Rete.IParameter[])">
            <param name="">id
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert will first pass the facts to the parameters. Once the
            parameters are set, it should call execute to Get the result.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Since the assertRight is a dummy, it doesn't do anything.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> retract right is a dummy, so it does nothing.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.ToString">
            <summary> Still need to implement the method to return string
            format of the node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TestNode.toPPString">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.TestNode.Bindings">
            <summary> for TestNode, setbindings does not apply
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.SlotParam">
            <author>  Peter Lin
            *
            TODO To change the template for this generated type comment go to
            Window - Preferences - Java - Code Style - Code Templates
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.AbstractParam">
            <author>  Peter Lin AbstractParam provides the common implementation of
            Parameter interface.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IParameter">
            <author>  Peter Lin
            *
            Parameter can be a value, a bound variable or the result of a function.
            It is up to the implementing class to provide the necessary logic.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IReturnValue">
            <author>  Peter Lin
            *
            ReturnValue defines the base methods to Get the value and type of
            the return value. Since users will be able to use CLIPS syntax
            to define functions, we provide this functionality.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IParameter.reset">
            <summary> In some cases, we may need to reset the parameter. For example,
            function and bound parameters may need to be reset, so the
            instance can be reused.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IParameter.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> Functions should use this method to Get the value from the parameter.
            Each parameter type will have logic to return the correct value
            or throw an exception if the class can't implicitly cast the value
            to the target value type.
            </summary>
            <param name="">engine
            </param>
            <param name="">valueType
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IParameter.ObjectBinding">
            <summary> If the parameter is an object binding, the method should return true
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractParam.reset">
            <summary> reset sets the Fact handle to null
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractParam.ValueType">
            <summary> Get the value type
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractParam.ObjectBinding">
            <summary> subclasses have to implement the method
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractParam.StringValue">
            <summary> the implementation will check if the value is a String. if it is, it
            casts the object to a String, otherwise it calls the object's toString()
            method.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractParam.BooleanValue">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.SlotParam.#ctor(Creshendo.Util.Rete.Slot)">
            <summary> 
            </summary>
            <param name="">type
            </param>
            <param name="">slot
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.SlotParam.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> Slot parameter is only used internally, so normal user functions
            should not need to deal with slot parameters.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.IReturnVector">
            <author>  Peter Lin
            *
            The ReturnVector can contain one or more items from a function.
            Functions can return a specific implementation of ReturnVector.
            This makes it easier to customize functions and process the
            results of a function.
            The interface extends IEnumerator, so 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IReturnVector.size">
            <summary> the number of items returned by the function
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IReturnVector.addReturnValue(Creshendo.Util.Rete.IReturnValue)">
            <summary> Fucntions should Add Return values in sequence using this method.
            </summary>
            <param name="">val
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.IReturnVector.Iterator">
            <summary> Class implementing the method should return itself, since
            ReturnVector extends IEnumerator.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.Random">
            <author>  Christian Ebert
            
            Returns a double value with a positive sign, greater than or equal to 0.0 and less 
            than 1.0. Returned values are chosen pseudorandomly with (approximately)
            uniform distribution from that range.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Random.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.PrintFunction">
            <author>  Peter Lin
            *
            PrintFucntion is pretty simple. It can any number of parameters and
            print it.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.PrintFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.PrintFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> The implementation will call Rete.writeMessage(). This means that
            if multiple output streams are set, the message will be printed to
            all of them.
            </summary>
        </member>
        <member name="M:Creshendo.Functions.PrintFunction.toPPString(Creshendo.Util.Rete.IParameter[],System.Int32)">
            <summary> Note: need to handle crlf correctly, for now leave it as is.
            </summary>
        </member>
        <member name="P:Creshendo.Functions.PrintFunction.Parameter">
            <summary> The implementation returns an array of Count 1 with Parameter.class
            as the only entry. Any function that can take an unlimited number
            of Parameters should return new Class[] {Parameter.class}.
            If a function doesn't take any parameters, the method should return
            null instead.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.PPrintTemplateFunction">
            Peter Lin
            
            PPrintTemplate stands for Pretty Print deftemplate. It does the same
            thing as (ppdeftemplate in CLIPS.
            
            
        </member>
        <member name="M:Creshendo.Functions.PPrintTemplateFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.PPrintTemplateFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> the function will printout one or more templates. This implementation
            is slightly different than CLIPS in that it can take one or more
            template names. The definition in CLIPS beginners guide states the 
            function does the following: (ppdeftemplate &lt;deftemplate-name>)
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.HashedNotEqBNode">
            <author>  Peter Lin
            
            HashedNotEqBNode2 indexes the right input for joins that use
            not equal to. It uses 2 levels of indexing. The first is the bindings
            for equal to, the second is not equal to.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an Alpha node.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left requires that we propogate the
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.ToString">
            <summary> Basic implementation will return string format of the betaNode
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNotEqBNode.toPPString">
            <summary> returs the node name + id and bindings
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.HashedAlphaMemoryImpl">
            <author>  Peter Lin
            *
            Basic implementation of Alpha memory. It uses HashMap for storing
            the indexes.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.#ctor(System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.addPartialMatch(Creshendo.Util.Rete.IHashIndex,Creshendo.Util.Rete.IFact)">
            <summary> addPartialMatch stores the fact with the factId as the
            key.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.clear">
            <summary> Clear the memory.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.removePartialMatch(Creshendo.Util.Rete.IHashIndex,Creshendo.Util.Rete.IFact)">
            <summary> Remove a partial match from the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.size">
            <summary> Return the number of memories of all hash buckets
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.iterator(Creshendo.Util.Rete.IHashIndex)">
            <summary> Return an GetEnumerator of the values
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedAlphaMemoryImpl.iterateAll">
            <summary>
            return an List with all the facts
            </summary>
            <returns></returns>
        </member>
        <member name="T:Creshendo.Functions.GetCurrentModuleFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.GetCurrentModuleFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.FocusFunction">
            <author>  Sebastian Reinartz
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.Math.Exp">
            <author>  Nikolaus Koemm
            
            Exp returns Euler's number raised to the power of the arguments.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Exp.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ExistPredJoin">
            <author>  Peter Lin
            
            ExistJoin is implemented differently than how CLIPS does it. According
            to CLIPS beginners guide, Exist is convert to (not (not (blah) ) ).
            Rather than do that, I'm experimenting with a specialized Existjoin
            node instead. The benefit is reduce memory and fewer nodes in the 
            network. 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an
            Alpha node.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left is different than retractRight for couple
            of reasons.
            <ul>
            <li> NotJoin will only propogate the facts from the left</li>
            <li> NotJoin never needs to merge the left and right</li>
            </ul>
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.ToString">
            <summary> simple implementation for toString. may need to change the format
            later so it looks nicer.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistPredJoin.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Util.Messagerouter.CLIPSLanguageAdapter">
            <summary> A simple LanguageAdapter that accepts only CLIPS as language. Any command
            will directly be forwarded to the CLIPSParser.
            
            </summary>
            <author>  Alexander Wilden, Christoph Emonds, Sebastian Reinartz
            
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Messagerouter.ILanguageAdapter">
            <summary> An Interface for LanguageAdapters used by the MessageRouter. A
            LanguageAdapter is responsible for the translation of a command into CLIPS,
            execute it in the Rete-engine and give back a result in the same language the
            command was send in. One LanguageAdapter may support multiple different
            languages.
            
            </summary>
            <author>  Alexander Wilden, Christoph Emonds, Sebastian Reinartz
            
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.ILanguageAdapter.Evaluate(Creshendo.Util.Rete.Rete,System.String,System.String)">
            <summary>
            Evaluates a command given in any language that is supported by this
            LanguageAdapter.
            </summary>
            <param name="engine">The engine.</param>
            <param name="command">The command.</param>
            <param name="language">The language.</param>
            <returns>
            The result returned from the Rete-engine in the given
            language.
            @throws ParseException
            </returns>
        </member>
        <member name="P:Creshendo.Util.Messagerouter.ILanguageAdapter.SupportedLanguages">
            <summary> Returns a String-Array containing all supported languages.
            
            </summary>
            <returns> The String-Array containing all supported languages.
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.CLIPSLanguageAdapter.Evaluate(Creshendo.Util.Rete.Rete,System.String,System.String)">
            <summary>
            Evaluates a command given in any language that is supported by this
            LanguageAdapter.
            </summary>
            <param name="engine">The engine.</param>
            <param name="command">The command.</param>
            <param name="language">The language.</param>
            <returns>
            The result returned from the Rete-engine in the given
            language.
            @throws ParseException
            </returns>
        </member>
        <member name="P:Creshendo.Util.Messagerouter.CLIPSLanguageAdapter.SupportedLanguages">
            <summary>
            Returns a String-Array containing all supported languages.
            </summary>
            <value></value>
            <returns> The String-Array containing all supported languages.
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.NTestNode">
            <author>  Peter Lin
            *
            TestNode extends BaseJoin. TestNode is used to evaluate functions.
            It may use values or bindings as parameters for the functions. The
            left input is where the facts would enter. The right input is a
            dummy input, since no facts actually enter.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.NTestNode.func">
            <summary> TestNode can only have 1 top level function
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.NTestNode.params_Renamed">
            <summary> the parameters to pass to the function
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.NTestNode.ppstring">
            <summary> by default the string is null, until the first time
            toPPString is called.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.#ctor(System.Int32,Creshendo.Functions.IFunction,Creshendo.Util.Rete.IParameter[])">
            <param name="">id
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert will first pass the facts to the parameters. Once the
            parameters are set, it should call execute to Get the result.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Since the assertRight is a dummy, it doesn't do anything.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> retract right is a dummy, so it does nothing.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.ToString">
            <summary> Still need to implement the method to return string
            format of the node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NTestNode.toPPString">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.NTestNode.Bindings">
            <summary> for TestNode, setbindings does not apply
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.BetaMemoryImpl">
            <author>  Peter Lin
            *
            BetaMemory stores the matches
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IBetaMemory">
            <author>  Peter Lin
            *
            Basic interface for BetaMemory. I created the interface after I coded up
            the implementation, so the interface has the important methods. Hopefully
            I won't need to change this interface much in the future.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.clear">
            <summary> Clear the beta memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.iterateRightFacts">
            <summary> Get the facts that match from the right side
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.matchCount">
            <summary> Get the match count
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.matched(Creshendo.Util.Rete.IFact)">
            <summary> check if a fact already matched
            </summary>
            <param name="">rightfact
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.addMatch(Creshendo.Util.Rete.IFact)">
            <summary> Add a match
            </summary>
            <param name="">rightfact
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.removeMatch(Creshendo.Util.Rete.IFact)">
            <summary> Remove a matched fact
            </summary>
            <param name="">rightfact
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IBetaMemory.toPPString">
            <summary> the implementing class needs to decide to format the
            matches in the beta memory
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IBetaMemory.Index">
            <summary> Get the index for the beta memory.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IBetaMemory.LeftFacts">
            <summary> classes implementing the interface should Get the
            Fact[] from the index
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.#ctor(Creshendo.Util.Rete.Index)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.iterateRightFacts">
            <summary> Return the array containing the facts entering
            the right input that matched
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.matched(Creshendo.Util.Rete.IFact)">
            <summary> The method will check to see if the fact has
            previously matched
            </summary>
            <param name="">rightfacts
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.addMatch(Creshendo.Util.Rete.IFact)">
            <summary> Add a match to the list
            </summary>
            <param name="">rightfacts
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.clear">
            <summary> Clear will Clear the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.matchCount">
            <summary> method simply returns the Count
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BetaMemoryImpl.toPPString">
            <summary> The implementation will append the facts for the left followed
            by double colon "::" and then the matches from the right
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.BetaMemoryImpl.Index">
            <summary> Return the index of the beta memory
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BetaMemoryImpl.LeftFacts">
            <summary> Get the array of facts
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rule.AndLiteralConstraint">
            <author>  Peter Lin
            *
            Literal constraint is a comparison between an object field and a concrete
            value. for example, account.name is equal to "Peter Lin". I originally,
            named the class something else, but since CLIPS uses literal constraint,
            I decided to change the name of the class. Even though I don't like the
            term literal constraint, it doesn't make sense to fight existing
            terminology.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.AndLiteralConstraint.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.AndLiteralConstraint.Negated">
            <summary> if the literal constraint is negated, the method returns true
            </summary>
            <returns>
            
            </returns>
            <summary> if the literal constraint is negated with a "~" tilda, call
            the method pass true.
            </summary>
            <param name="">negate
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.AndLiteralConstraint.Name">
            <summary> the name is the slot name
            </summary>
            <summary> set the slot name as declared in the rule
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.AndLiteralConstraint.Value">
            <summary> Set the value of the constraint. It should be a concrete value and
            not a binding.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.WarningSummary">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rule.ISummary">
            <summary> The purpose of Summary interface is to define common methods for
            getting the validation summary of a rule. If a rule passes validation
            there may not be any summary or the summary have no details.
            
            If the validation failed, the summary should contain information about
            what failed and why.
            </summary>
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.ISummary.addMessage(System.String)">
            <summary> Add a message about the error or warning
            </summary>
            <param name="">reason
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.ISummary.Messages">
            <summary> Get the messages as an array of String
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.ISummary.Message">
            <summary> return the errors and warnings as a single string
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.WarningSummary.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ValueParam">
            <author>  Peter Lin
            *
            Value parameter is meant for values. It extends AbstractParam, which provides
            implementation for the convienance methods that convert the value to
            primitive types.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ValueParam.#ctor(System.Int32,System.Object)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ValueParam.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> Value parameter don't need to resolve the value, so it just
            returns it.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ValueParam.reset">
            <summary> implementation sets the value to null and the type to Object
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.ValueParam.ValueType">
            <summary> The value types are defined in woolfel.engine.rete.Constants
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.ValueParam.Value">
            <summary> Method will return the value as on Object. This means primitive
            values are wrapped in their Object equivalent.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.UnProfileFunction">
            <author>  Peter Lin
            *
            ProfileFunction is used to turn on profiling. It provides basic
            profiling of assert, retract, Add activation, Remove activation
            and fire.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.UnProfileFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.TestConditionCompiler">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 12, 2007 2:18:29 PM
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.TestConditionCompiler.compileJoin(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule)">
            <summary> the method is responsible for compiling a TestCE pattern to a testjoin node.
            It uses the globally declared prevCE and prevJoinNode
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Deffact">
            <author>  Peter Lin
            
            Deffact is a concrete implementation of Fact interface. It is
            equivalent to deffact in CLIPS.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IFact">
            <author>  Peter Lin
            
            Base interface for Facts
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.getSlotValue(System.Int32)">
            <summary> Return the value at the given slot id
            </summary>
            <param name="">id
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.getSlotId(System.String)">
            <summary> Return id of the given slot name
            </summary>
            <param name="">name
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.toFactString">
            <summary> Method will return the fact in a string format.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.updateSlots(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.Slot[])">
            <summary> If we need to update slots
            </summary>
            <param name="">slots
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.clear">
            <summary> finalize the object and make it ready for GC
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.timeStamp">
            <summary> the timestamp for the fact
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IFact.equalityIndex">
            <summary> return the equality index
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IFact.ObjectInstance">
            <summary> Return the object instance linked to the fact
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IFact.FactId">
            <summary> Return the unique ID for the fact
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IFact.Deftemplate">
            <summary> Return the Deftemplate for the fact
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="F:Creshendo.Util.Rete.Deffact.id">
            <summary> the Fact id must be unique, since we use it for the indexes
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.#ctor(Creshendo.Util.Rete.Deftemplate,System.Object,Creshendo.Util.Rete.Slot[],System.Int64)">
            <summary> this is the default constructor
            </summary>
            <param name="">instance
            </param>
            <param name="">values
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.getSlotValue(System.Int32)">
            <summary> Method returns the value of the given slot at the
            id.
            </summary>
            <param name="">id
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.getSlotId(System.String)">
            <summary> Method will iterate over the slots until finds the match.
            If no match is found, it return -1.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.toFactString">
            <summary> Method will return the fact in a string format.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.equalityIndex">
            <summary> Returns the string format for the fact without the fact-id. this is used
            to make sure that if an user asserts an equivalent fact, we can easily
            check it.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.updateSlots(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.Slot[])">
            <summary> update the slots
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.timeStamp">
            <summary> the implementation returns nano time
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.clear">
            <summary> this will make sure the fact is GC immediately
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.compileBinding(Creshendo.Util.Rule.IRule)">
            <summary> 
            </summary>
            <param name="">util
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.hasBinding">
            <summary> In some cases, a deffact may have bindings. This is a design choice. When
            rules are parsed and compiled, actions that assert facts are converted to
            Deffact instances with BoundParam for the slot value.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.slotHash">
            <summary> this is used by the EqualityIndex class
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.resetID(Creshendo.Util.Rete.Deffact)">
            <summary> this is used to reset the id, in the event an user tries to
            assert the same fact again, we reset the id to the existing one.
            </summary>
            <param name="">fact
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.slotEquals(Creshendo.Util.Rete.Deffact)">
            <summary> the current implementation only compares the values, since the slot
            names are equal. It would be a waste of time to compare the slot
            names. The exception to the case is when a deftemplate is changed.
            Since that feature isn't supported yet, it's currently not an issue.
            Even if updating deftemplates is added in the future, the deffacts
            need to be updated. If the deffacts weren't updated, it could lead
            to NullPointerExceptions.
            </summary>
            <param name="">fact
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deffact.cloneFact">
            <summary> Convienance method for cloning a fact. If a slot's value is a BoundParam,
            the cloned fact uses the value of the BoundParam.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Deffact.setFactId">
            <summary> if the factId is -1, the fact will Get will the Current fact id
            from Rete and set it. Otherwise, the fact will use the same one.
            </summary>
            <param name="">engine
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Deffact.ObjectInstance">
            <summary> If the fact is a shadow fact, it will return the
            object instance. If the fact is just a deffact
            and isn't a shadow fact, it return null.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Deffact.FactId">
            <summary> Return the long factId
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Deffact.Deftemplate">
            <summary> Return the deftemplate for the fact
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalDeffact.toPPString">
            <summary> the class overrides the method to include the additional
            attributes.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.StringParam">
            <author>  Peter Lin
            *
            Value parameter is meant for values. It extends AbstractParam, which provides
            implementation for the convienance methods that convert the value to
            primitive types.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.StringParam.#ctor(System.Int32,System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.StringParam.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> String parameters do not need to do any lookup, so it just
            returns the value.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.StringParam.reset">
            <summary> implementation sets the value to null and the type to Object
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.StringParam.ValueType">
            <summary> The value types are defined in woolfel.engine.rete.Constants
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.StringParam.Value">
            <summary> Method will return the value as on Object. This means primitive
            values are wrapped in their Object equivalent.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.SpoolFunction">
            <author>  Peter Lin
            
            The purpose of spool function is to capture the output to a file,
            and make it easier to record what happens. This is inspired by
            Oracle SqlPlus spool function.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.SpoolFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.IRule">
            <author>  Peter Lin
            *
            The rule interface design is influenced by RuleML 0.8. It is also
            influenced by CLIPS, but with some important differences. The 
            interface assumes it acts as a bridge between a Rule Parser, which 
            parses some text and produces the necessary artifacts and a rule
            compiler which generates RETE nodes.
            For that reason, the interface defines methods for adding Join
            nodes and retrieving the last node in the rule. These convienance
            method are present to make it easier to write rule parsers and
            compilers.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IScope">
            <author>  pete
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.setBindingValue(System.Object,System.Object)">
            <summary> A rule action can create local bindings, so a rule needs to provide
            a way to store and retrieve bindings.
            </summary>
            <param name="">key
            </param>
            <param name="">value
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.getBindingValue(System.String)">
            <summary> Return the value of the for the binding
            </summary>
            <param name="key">is the name of the variable
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.addBinding(System.String,Creshendo.Util.Rete.Binding)">
            <summary> Add a new binding to the rule with the variable as the key
            </summary>
            <param name="">key
            </param>
            <param name="">bind
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.getBinding(System.String)">
            <summary> Get the Binding object for the given key
            </summary>
            <param name="">varName
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.copyBinding(System.String)">
            <summary> utility method for copying bindings
            </summary>
            <param name="">varName
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.copyPredicateBinding(System.String,System.Int32)">
            <summary> utility method for copying predicate bindings
            </summary>
            <param name="">varName
            </param>
            <param name="">operator
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.resetTriggerFacts">
            <summary> After the actions of a rule are executed, reset should be called
            to make sure the rule doesn't hold on to the facts.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.resolveTemplates(Creshendo.Util.Rete.Rete)">
            <summary> this method needs to be called before rule compilation begins. It
            avoids doing multiple lookups for the corresponding template.
            </summary>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rule.IRule.toPPString">
            <summary> Return a pretty print formatted string for the rule.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.AutoFocus">
            <summary> if the rule is set to autofocus, it returns true
            </summary>
            <returns>
            
            </returns>
            <summary> if the rule should fire even when the module is not in focus,
            call the method with true
            </summary>
            <param name="">auto
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Comment">
            <summary> if users want to give a rule a comment, the method will return it.
            otherwise it should return zero length string
            </summary>
            <returns>
            
            </returns>
            <summary> set the comment of the rule. it should be a descriptive comment
            about what the rule does.
            </summary>
            <param name="">text
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Complexity">
            <summary> Get the complexity of the rule, which measure how many conditions
            a rule has
            </summary>
            <returns>
            
            </returns>
            <summary> set the complexity of the rule. this should be calculated
            by the rule engine or rule compiler
            </summary>
            <param name="">complexity
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.EffectiveDate">
            <summary> return the effective date in milliseconds
            </summary>
            <returns>
            
            </returns>
            <summary> Be default classes implementing the interface should set
            the effective date to zero. only when the user sets the
            date should it have a non-zero positive long value.
            </summary>
            <param name="">mstime
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.ExpirationDate">
            <summary> return the expiration date in milliseconds
            </summary>
            <returns>
            
            </returns>
            <summary> by default classes implementing the interface should set
            the expiration date to zero. only when the user sets the
            date should it have a non-zero positive value greater
            than the effective date.
            </summary>
            <param name="">mstime
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Name">
            <summary> Add a conditional element to the rule
            </summary>
            <param name="">cond
            
            </param>
            <summary> Get the name of the rule
            </summary>
            <returns>
            
            </returns>
            <summary> set the name of the rule
            </summary>
            <param name="">name
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.NoAgenda">
            <summary> if the rule should skip the agenda and fire immediately,
            the method returns true. By default it should be false
            </summary>
            <returns>
            
            </returns>
            <summary> if a rule should skip the agenda, set it to true
            </summary>
            <param name="">agenda
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.RememberMatch">
            <summary> classes implementing the interface can choose to ignore
            this rule property. Sumatra currently provides the ability
            to turn off AlphaMemory. By default, it is set to true.
            If a user wants to turn off AlphaMemory for a given rule,
            set it to false.
            </summary>
            <returns>
            
            </returns>
            <summary> to turn of alpha memory, set it to false
            </summary>
            <param name="">match
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Salience">
            <summary> Get the salience of the rule
            </summary>
            <returns>
            
            </returns>
            <summary> to lower the priority of a rule, set the value lower
            </summary>
            <param name="">sal
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Version">
            <summary> the version of the rule
            </summary>
            <returns>
            
            </returns>
            <summary> set the version of the rule
            </summary>
            <param name="">ver
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Watch">
            <summary> watch is used for debugging
            </summary>
            <returns>
            
            </returns>
            <summary> to debug a rule, set the watch to true
            </summary>
            <param name="">watch
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Active">
            <summary> by default a rule should return true
            </summary>
            <returns>
            
            </returns>
            <summary> to turn off a rule, call the method with false
            </summary>
            <param name="">active
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.TemporalActivation">
            <summary> if the rule uses temporal facts, the method should return
            true. the defrule must declare temporal-activation true
            </summary>
            <returns>
            
            </returns>
            <summary> set the rule to use temporal activation
            </summary>
            <param name="">temporalActivation
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.LastNode">
            <summary> The method should return the last node in the rule, not counting
            the terminal node.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.Module">
            <summary> Return the module the rule belongs to. A rule can only belong to a
            single module.
            </summary>
            <returns>
            
            </returns>
            <summary> When the rule is compiled, the rule compiler needs to set the module
            so that the terminalNode can Add the activation to the correct
            activationList.
            </summary>
            <param name="">mod
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.BindingIterator">
            <summary> Get a GetEnumerator to the Binding objects
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.BindingCount">
            <summary> Get a count of the Binding
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.IRule.TriggerFacts">
            <summary> In case an user wants to Get the trigger facts in the right hand
            side of the rule.
            </summary>
            <returns>
            
            </returns>
            <summary> We need to set the trigger facts, so the rule action can look up
            values easily.
            </summary>
            <param name="">facts
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.NewFunction">
            <author>  Christian Ebert
            
            Creates a Java Object and returns it.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rule.Defrule">
            <author>  Peter Lin
            *
            A basic implementation of the Rule interface
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.active">
            <summary> by default a rule is active, unless set to false
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.direction">
            <summary> Be default, the rule is set to forward chaining
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.effectiveDate">
            <summary> default is set to zero
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.expirationDate">
            <summary> default is set to zero
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.noAgenda">
            <summary> by default noAgenda is false
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.temporalActivation">
            <summary> default for temporal activation is false
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.Defrule.watch">
            <summary> by default watch is off
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.addJoinNode(Creshendo.Util.Rete.BaseJoin)">
            <summary> Add join nodes to the rule
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.setBindingValue(System.Object,System.Object)">
            <summary> the current implementation simply replaces the existing
            value if one already exists.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.getBindingValue(System.String)">
            <summary> return the value associated with the binding
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.resetTriggerFacts">
            <summary> reset the trigger facts after all the actions have executed.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.addBinding(System.String,Creshendo.Util.Rete.Binding)">
            <summary>
            Method will only Add the binding if it doesn't already
            exist.
            </summary>
            <param name="key"></param>
            <param name="bind"></param>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.getBinding(System.String)">
            <summary>
            Return the Binding matching the variable name
            </summary>
            <param name="varName"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.copyBinding(System.String)">
            <summary>
            Get a copy of the Binding using the variable name
            </summary>
            <param name="varName"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rule.Defrule.Clone">
            <summary> TODO need to finish implementing the clone method
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.Defrule.Active">
            <summary> by default a rule should return true
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.Defrule.Joins">
            <summary> Get the array of join nodes
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.Defrule.TriggerFacts">
            <summary> This should be called when the action is being fired. after the rule
            actions are executed, the trigger facts should be reset. The primary
            downside of this design decision is it won't work well with multi-
            threaded parallel execution. Since Sumatra has no plans for implementing
            parallel execution using multi-threading, the design is not an issue.
            Implementing multi-threaded parallel execution isn't desirable and
            has been proven to be too costly. A better approach is to queue assert
            retract and process them in sequence.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.Defrule.BindingIterator">
            <summary> The method will return the Bindings in the order they
            were added to the utility.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.Defrule.BindingCount">
            <summary> Returns the number of unique bindings. If a binding is
            used multiple times to join several facts, it is only
            counted once.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.DefinstanceFunction">
            <author>  Peter Lin
            *
            Definstance will assert an object instance using Rete.assert(Object).
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.DefinstanceFunction.Parameter">
            <summary> The function expects a single BoundParam that is an object binding
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.AbstractSlot">
              Peter Lin
            *
            AbstractSlot Contains common attributes of Slot, multislot and
            binding. Slot classes need to implement the clone method for
            cloning the slots. This is necessary because slots are used to
            parse CLIPS and for the RETE nodes.
            
            
            
            
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractSlot.depth">
            <summary> depth is a place holder for ordered facts, which is a list
            of symbols. For the first version, ordered facts are not
            implemented. it is also used in the case a condition has
            multiple equal/not equal as in (attr2 "me" | "you" | ~"her" | ~"she")
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractSlot.hasDefault">
            <summary> in some cases, users may want a template to have a default value
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractSlot.id">
            <summary> the id of the slot
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractSlot.name">
            <summary> The name of the slot
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractSlot.nodeCount">
            <summary> node count is used to keep track of how many nodes use the given
            slot. This is done for statistical purposes, which serve 3 main
            functions.
            1. provide a way to calculate the relative importance of a slot
            with regard to the entire RETE network
            2. provide a way to optimize runtime execution
            3. provide valuable information for engine management
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AbstractSlot.type">
            <summary> The type of the value
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractSlot.Clone">
            <summary> A convienance method to clone slots. subclasses must implement
            this method.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractSlot.incrementNodeCount">
            <summary> Increment the node count
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractSlot.decrementNodeCount">
            <summary> decrement the node count
            *
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractSlot.Name">
            <summary> Get the name of the slot
            </summary>
            <returns>
            
            </returns>
            <summary> Set the name of the slot
            </summary>
            <param name="">text
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractSlot.Id">
            <summary> the id is the column id, this is the sequence java
            introspection returns the fields for the object
            </summary>
            <returns>
            
            </returns>
            <summary> Set the column id for the slot. the id is the position
            of the slot in the deftemplate
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractSlot.NodeCount">
            <summary> return the number of nodes the given slot participates
            in. It may not be a complete count. In some cases, it
            may only count the direct successors of ObjectTypeNode
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.TokenMgrError.LexicalError">
            Lexical error occured.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.TokenMgrError.StaticLexerError">
            An attempt wass made to create a second instance of a static token manager.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.TokenMgrError.InvalidLexicalState">
            Tried to change to an invalid lexical state.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.TokenMgrError.LoopDetected">
            Detected (and bailed out of) an infinite loop in the token manager.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.TokenMgrError.errorCode">
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.TokenMgrError.AddEscapes(System.String)">
            Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.TokenMgrError.GetLexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            Returns a detailed message for the Exception when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
               EOFSeen     : indicates if EOF caused the lexicl error
               curLexState : lexical state in which this error occured
               errorLine   : line number when the error occured
               errorColumn : column number when the error occured
               errorAfter  : prefix that was seen before this error occured
               curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
        </member>
        <member name="P:Creshendo.Util.Parser.Clips2.TokenMgrError.Message">
             You can also modify the body of this method to customize your error messages.
             For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
             of end-users concern, so you can return something like : 
            
                 "Internal Error : Please file a bug report .... "
            
             from this method for such cases in the release version of your parser.
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.#ctor(Creshendo.Util.Rete.Rete)">
            <summary>
            The constructor for a message router.
            </summary>
            <param name="engine">The engine.</param>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.postMessageEvent(Creshendo.Util.Messagerouter.MessageEventArgs)">
            <summary>
            Posts the message event.
            </summary>
            <param name="messageEventArgsRenamed">The event_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.openChannel(System.String,System.IO.StreamReader)">
            <summary>
            Opens the channel.
            </summary>
            <param name="channelName">Name of the channel.</param>
            <param name="inputStream">The input stream.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.openChannel(System.String,System.IO.TextReader,Creshendo.Util.Messagerouter.InterestType)">
            <summary>
            Opens the channel.
            </summary>
            <param name="channelName">Name of the channel.</param>
            <param name="inputStream">The input stream.</param>
            <param name="interestType">Type of the interest.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.openChannel(System.String,System.IO.TextReader)">
            <summary>
            Opens the channel.
            </summary>
            <param name="channelName">Name of the channel.</param>
            <param name="reader">The reader.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.openChannel(System.String,System.IO.StreamReader,Creshendo.Util.Messagerouter.InterestType)">
            <summary>
            Opens the channel.
            </summary>
            <param name="channelName">Name of the channel.</param>
            <param name="reader">The reader.</param>
            <param name="interestType">Type of the interest.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.openChannel(System.String)">
            <summary>
            Opens the channel.
            </summary>
            <param name="channelName">Name of the channel.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.openChannel(System.String,Creshendo.Util.Messagerouter.InterestType)">
            <summary>
            Opens the channel.
            </summary>
            <param name="channelName">Name of the channel.</param>
            <param name="interestType">Type of the interest.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageRouter.closeChannel(Creshendo.Util.Messagerouter.ICommunicationChannel)">
            <summary>
            Closes the channel.
            </summary>
            <param name="channel">The channel.</param>
        </member>
        <member name="P:Creshendo.Util.Messagerouter.MessageRouter.ReteEngine">
            <summary>
            returns the underlying Rete-engine.
            </summary>
            <value>The rete engine.</value>
            <returns> The Rete-engine used in this MessageRouter-instance.
            </returns>
        </member>
        <member name="T:Creshendo.Functions.ValidateRuleFunction">
            <author>  Peter Lin
            
            WatchFunction allows users to watch different engine process, like
            activations, facts and rules.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ValidateRuleFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.UnWatchFunction">
            <author>  Peter Lin
            
            WatchFunction allows users to watch different engine process, like
            activations, facts and rules.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.UnWatchFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ITemplate">
            <author>  Peter Lin
            *
            Template defines the methods to access an object, which is the
            equivalent of un-ordered facts. It defines all the necessary
            methods for Deftemplate.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ITemplate.getSlot(System.String)">
            <summary> Return the slot with the String name
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ITemplate.getSlot(System.Int32)">
            <summary> Get the Slot at the given column id
            </summary>
            <param name="">column
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ITemplate.getColumnIndex(System.String)">
            <summary> Get the column index with the given name
            </summary>
            <param name="">name
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ITemplate.createFact(System.Object,Creshendo.Util.Rete.Defclass,System.Int64)">
            <summary> 
            </summary>
            <param name="">data
            </param>
            <param name="">id
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ITemplate.inUse">
            <summary> If the template is currently in use, we should not Remove it
            until all the dependent rules are removed first.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ITemplate.toString">
            <summary> 
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.ITemplate.Name">
            <summary> The name of the template may be the fully qualified
            class name, or an alias.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.ITemplate.NumberOfSlots">
            <summary> templates may have 1 or more slots. A slot is a named
            column with a specific type of value.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.ITemplate.AllSlots">
            <summary> Return an array of all the slots.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.ITemplate.Watch">
            <summary> if watch is set to true, the rule engine will pass events
            when the fact traverses the network.
            </summary>
            <returns>
            
            </returns>
            <summary> Set the watch flag
            </summary>
            <param name="">watch
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.ITemplate.Parent">
            <summary> If a template has a parent, the method should
            return the parent, otherwise it should return
            null
            </summary>
            <returns>
            
            </returns>
            <summary> set the parent template
            </summary>
            <param name="">parent
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.ITemplate.ClassName">
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.StringTrimFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringTrimFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Slot2">
            Peter Lin
            *
            Slot2 is used for conditions that evaluate against multiple values.
            For example: (attr2 "me" | "you" | ~"her" | ~"she")
            
            Rather than evaluate a long sequence of equal/not equal sequentially,
            we use two lists: equal and notequal. Slot2 is used exclusive for
            a sequence of "or" value comparisons.
            
            
        </member>
        <member name="T:Creshendo.Util.Rete.Slot">
            <author>  Peter Lin
            *
            Slot is similar to CLIPS slots, though slightly different.
            
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Slot.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.Slot"/> class.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Slot.#ctor(System.String)">
            <summary>
            Create a new instance with a given name
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Slot.#ctor(System.String,System.Object)">
            <summary>
            For convenience you can create here a slot with a given value directly
            </summary>
            <param name="name">The name.</param>
            <param name="val">The val.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Slot.inspectType">
            <summary> method will look at the value and set the int type
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Slot.Clone">
            <summary> A convienance method to clone slots
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Slot.Value">
            <summary>
            Get the value of the slot
            </summary>
            <value>The value.</value>
            <returns>
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Slot2.Clone">
            <summary> A convienance method to clone slots
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Slot2.Value">
            <summary> the method doesn't apply to slot2
            </summary>
            <summary> method will check to see if the object is a collection. if it is,
            it will iterate over the collection and Add each one to the right
            list.
            </summary>
            <param name="">val
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Slot2.EqualList">
            <summary> Get the list of values the slot should equal to
            </summary>
            <returns>
            
            </returns>
            <summary> set the values the slot should equal to 
            </summary>
            <param name="">val
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Slot2.NotEqualList">
            <summary> Get the list of values the slot should not equal to
            </summary>
            <returns>
            
            </returns>
            <summary> set the list of values the slot should not equal to
            </summary>
            <param name="">val
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.Math.Radians">
            <author>  Nikolaus Koemm
            
            Radians converts an angle measured in degrees to an approximately equivalent
            angle measured in radians.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Radians.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Messages">
            <author>  Peter Lin
            *
            Messages is a basic resource bundle. It's responsible for getting
            the error messages and other resource bundle related values.
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.MemberFunction">
            <author>  Christian Ebert
            
            Calls a method of a specified object.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.HashedEqNJoin">
            <author>  Peter Lin
            
            HashEqNJoin stands for Hashed Equal NotJoin. It is different from
            NotJoin. The right facts are hashed to improve performance. This means
            the node performs index joins to see if there's a matching facts on
            the right side. If there is, the node will propogate without
            performing evaluation. We can do this because only facts that match
            would have the same index.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an Alpha node.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left is different than retractRight for couple of
            reasons.
            <ul>
            <li> NotJoin will only propogate the facts from the left</li>
            <li> NotJoin never needs to merge the left and right</li>
            </ul>
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.addSuccessorNode(Creshendo.Util.Rete.TerminalNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> NotJoin has to have a special addSuccessorNode since it needs
            to just propogate the left facts if it has zero matches.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.ToString">
            <summary> method returns a simple format for the node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqNJoin.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.DefaultRuleCompiler">
            <author>  Peter Lin
            *
            DefaultRuleCompiler is a simple implementation. It's for research purposes
            for now. It may become a full blown rule compiler later, but for now,
            I just need a simple compiler to load my samples rule to test the JIT
            algorithm.
            
            
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IRuleCompiler">
            <author>  Peter Lin
            *
            The purpose of a RuleCompiler is to convert a Rule object into
            the appropriate RETE network. We have a generic interface, so
            that others can implement their own RuleCompiler.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IRuleCompiler.addRule(Creshendo.Util.Rule.IRule)">
            <summary>
            A rule can be added dynamically at runtime to an existing
            engine. If the engine wasn't able to Add the rule, it
            will throw an exception.
            </summary>
            <param name="rule">The rule.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IRuleCompiler.addObjectTypeNode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary>
            Add a new ObjectTypeNode to the network
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IRuleCompiler.removeObjectTypeNode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary>
            Remove an ObjectTypeNode from the network. This should be
            when the rule engine isn't running. When an ObjectTypeNode
            is removed, all nodes and rules using the ObjectTypeNode
            need to be removed.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IRuleCompiler.getObjectTypeNode(Creshendo.Util.Rete.ITemplate)">
            <summary>
            Look up the ObjectTypeNode using the Template
            </summary>
            <param name="template">The template.</param>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IRuleCompiler.ValidateRule">
            <summary>
            return whether the rule compiler is set to validate the rule
            before compiling it.
            </summary>
            <value><c>true</c> if [validate rule]; otherwise, <c>false</c>.</value>
            <returns>
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.addRule(Creshendo.Util.Rule.IRule)">
            <summary> Here is a description of the compilation algorithm.
            1. iterate over the conditional elements
            i. generate the alpha nodes
            a. literal constraints generate alpha node
            b. predicate constaints that compare against a literal generate alpha node
            ii. calculate the bindings
            a. each binding has a rowId
            b. NOT and EXIST CE do not increment the rowId
            2. iterate over the conditional elements
            i. generate the beta nodes
            ii. attach the Left Input adapater nodes
            iii. attach the join nodes to the alpha nodes
            3. create the terminal node and attach to the last
            join node.
            
            This means the rule compiler takes a 2 pass approach to
            compiling rules. At the start of the method, it sets 3
            attributes to null: prevCE, prevJoinNode, joinNode.
            Those attributes are used by the compile join methods,
            so it's important to set it to null at the start. If
            we don't the Current rule won't compile correctly.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.addObjectTypeNode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary> implementation uses the deftemplate for the HashMap key and the
            node for the value. If the node already exists in the HashMap,
            or the key already exists, the compiler will not Add it to the
            network.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.removeObjectTypeNode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary> Method will Remove the ObjectTypeNode and call Clear on it.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.getObjectTypeNode(Creshendo.Util.Rete.ITemplate)">
            <summary> if the ObjectTypeNode does not exist, the method will return null.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.createTerminalNode(Creshendo.Util.Rule.IRule)">
            <summary>
            The method is responsible for creating the right terminal node based on the
            settings for the rule.
            </summary>
            <param name="rl">The rl.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.findObjectTypeNode(System.String)">
            <summary>
            Finds the object type node.
            </summary>
            <param name="templateName">Name of the template.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileConstraint(Creshendo.Util.Rule.LiteralConstraint,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rule.IRule)">
            <summary>
            method compiles a literalConstraint
            </summary>
            <param name="cnstr">The CNSTR.</param>
            <param name="templ">The templ.</param>
            <param name="rule">The rule.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileConstraint(Creshendo.Util.Rule.AndLiteralConstraint,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rule.IRule)">
            <summary>
            method compiles AndLiteralConstraint into alpha nodes
            </summary>
            <param name="cnstr">The CNSTR.</param>
            <param name="templ">The templ.</param>
            <param name="rule">The rule.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileConstraint(Creshendo.Util.Rule.OrLiteralConstraint,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rule.IRule)">
            <summary>
            method compiles OrLiteralConstraint into alpha nodes
            </summary>
            <param name="cnstr">The CNSTR.</param>
            <param name="templ">The templ.</param>
            <param name="rule">The rule.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileConstraint(Creshendo.Util.Rule.BoundConstraint,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rule.IRule,System.Int32)">
            <summary>
            method creates Bindings from the bound constraint and adds them to
            the Rule.
            </summary>
            <param name="cnstr">The CNSTR.</param>
            <param name="templ">The templ.</param>
            <param name="rule">The rule.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileConstraint(Creshendo.Util.Rule.PredicateConstraint,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rule.IRule,System.Int32)">
            <summary>
            Compiles the constraint.
            </summary>
            <param name="cnstr">The CNSTR.</param>
            <param name="templ">The templ.</param>
            <param name="rule">The rule.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileJoins(Creshendo.Util.Rule.IRule)">
            <summary>
            Compiles the joins.
            </summary>
            <param name="rule">The rule.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.compileActions(Creshendo.Util.Rule.IRule,Creshendo.Util.Rete.IAction[])">
            <summary>
            The method is responsible for compiling the string form of the
            actions to the equivalent functions.
            </summary>
            <param name="rule">The rule.</param>
            <param name="acts">The acts.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.attachJoinNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.BaseJoin)">
            <summary>
            Method will attach a new JoinNode to an ancestor node. An ancestor
            could be LIANode, AlphaNode or BetaNode.
            </summary>
            <param name="last">The last.</param>
            <param name="join">The join.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.findLIANode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary>
            method will find the first LeftInputAdapter node for the
            ObjectTypeNode. There should only be one that is a direct
            successor.
            </summary>
            <param name="otn">The otn.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultRuleCompiler.notifyListener(Creshendo.Util.Rete.CompileMessageEventArgs)">
            <summary>
            basic method iterates over the listeners and passes the event, checking
            what kind of event it is and calling the appropriate method.
            </summary>
            <param name="eventArgs">The event_ renamed.</param>
        </member>
        <member name="T:Creshendo.Util.Rete.DefaultReturnValue">
            <author>  Peter Lin
            
            DefaultReturnValue simply extends ValueParam. In many ways, input parameters
            and return values have similar needs. Both have to contain information about
            the type of value. ReturnValue defines the basic methods for getting the
            value and figuring out what type it is.
            <ol>
            <li> Parameter interface extends ReturnValue</li>
            <li> AbstractParam implements Parameter interface</li>
            <li> ValueParam extends AbstractParam</li>
            </ol>
            The convienance methods in ReturnValue should make it easier to access the
            values.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultReturnValue.#ctor(System.Int32,System.Object)">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.DefaultComplexity">
            <author>  Peter Lin
            *
            TODO To change the template for this generated type comment go to
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.DefaultComplexity.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.AlphaNodeOr">
            <author>  Peter Lin
            *
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNodeOr.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNodeOr.useCount">
            <summary> The useCount is used to keep track of how many times
            an Alpha node is shared. This is needed so that we
            can dynamically Remove a rule at run time and Remove
            the node from the network. If we didn't keep count,
            it would be harder to figure out if we can Remove the node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.incrementUseCount">
            <summary> every time the node is shared, the method
            needs to be called so we keep an accurate count.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.decrementUseCount">
            <summary> every time a rule is removed from the network
            we need to decrement the count. Once the count
            reaches zero, we can Remove the node by calling
            it's finalize.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation will first check to see if the fact already matched.
            If it did, the fact stops and doesn't go any further. If it doesn't,
            it will attempt to evaluate it and Add the fact if it matches.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract a fact from the node
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.evaluate(Creshendo.Util.Rete.IFact)">
            <summary> evaluate the node's value against the slot's value. The method
            uses Evaluate class to perform the evaluation
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.hashString">
            <summary> method returns toString() for the hash
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.ToString">
            <summary> Method returns the string format of the node's condition. later on
            this should be cleaned up.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeOr.toPPString">
            <summary> Method returns the pretty printer formatted string of the node's
            condition. For now, the method just replaces the operator. It might
            be nice to replace the slot id with the slot name.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeOr.Shared">
            <summary> the first time the RETE compiler makes the node shared,
            it needs to increment the useCount.
            </summary>
            <param name="">share
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeOr.Slot">
            <summary> Set the slot id. The slot id is the deftemplate slot id
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeOr.UseCount">
            <summary> return the times the node is shared
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeOr.Operator">
            <summary> method is not implemented, since it doesn't apply
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Agenda">
            <author>  Peter Lin
            *
            The design of the agenda is based on CLIPS, which uses modules to
            contain different rulesets. When a new activation is added to the
            agenda, it is added to a specific module. By default, the rule
            engine creates a main module. If no additional modules are created,
            all activations are added to the main module. If there are multiple
            modules, the activation is added to the activation list of that
            given module.
            Only the activations of the current module will be fired.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.Agenda.modules">
            <summary> The org.jamocha.rete.util.List for the modules.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Agenda.#ctor(Creshendo.Util.Rete.Rete)">
            <summary> The agenda takes an instance of Rete. the agenda needs a
            handle to the engine to do work.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Agenda.addActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Add an activation to the agenda.
            </summary>
            <param name="">actv
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Agenda.addActivationWProfile(Creshendo.Util.Rete.IActivation)">
            <summary> if profiling is turned on, the method is called to Add
            new activations to the agenda
            </summary>
            <param name="">actv
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Agenda.removeActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Method is called to Remove an activation from the agenda.
            </summary>
            <param name="">actv
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Agenda.removeActivationWProfile(Creshendo.Util.Rete.IActivation)">
            <summary> if the profiling is turned on for Remove, the method is
            called to Remove activations.
            </summary>
            <param name="">actv
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Agenda.clear">
            <summary> Clear will Clear all the modules and Remove all activations
            </summary>
        </member>
        <member name="T:Creshendo.Functions.VersionFunction">
            <author>  Peter Lin
            *
            ClearFunction will call Rete.Clear()
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.VersionFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.VersionFunction.Parameter">
            <summary> The function does not take any parameters
            </summary>
        </member>
        <member name="T:Creshendo.Functions.StringReplaceFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringReplaceFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.StringLowerFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringLowerFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.StringLengthFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringLengthFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Rete">
            <author>  Peter Lin
            
            This is the main Rete engine class. For now it's called Rete, but I may
            change it to Engine to be more generic.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.Rete.defclass">
            <summary> the key is the Class object. The value is the defclass. the defclass is
            then used to lookup the deftemplate in the current Module.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Rete.functions">
            <summary> this is the HashMap for all functions. This means all function names are
            unique.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Rete.listeners">
            <summary> an org.jamocha.rete.util.List for the listeners
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.ruleAdded(System.Object,Creshendo.Util.Rete.CompileMessageEventArgs)">
            <summary>
            For now, this is not implemented
            </summary>
            <param name="messageEventArgsRenamed">The event_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.ruleRemoved(System.Object,Creshendo.Util.Rete.CompileMessageEventArgs)">
            <summary>
            For now, this is not implemented
            </summary>
            <param name="messageEventArgsRenamed">The event_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.compileError(System.Object,Creshendo.Util.Rete.CompileMessageEventArgs)">
            <summary>
            For now, this is not implemented
            </summary>
            <param name="messageEventArgsRenamed">The event_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.init">
            <summary> initialization logic should go here
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.clearObjects">
            <summary> Clear the objects from the working memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.clearFacts">
            <summary> Clear the deffacts from the working memory. This does not include facts
            asserted using assertObject.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.clearAll">
            <summary> Clear all objects and deffacts
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.close">
            <summary> Method will Clear the engine of all rules, facts and objects.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.fire(System.Int32)">
            <summary>
            this is useful for debugging purposes. clips allows the user to fire 1
            rule at a time.
            </summary>
            <param name="count">The count.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.fire">
            <summary>
            this is the normal fire. it will fire all the rules that have matched
            completely.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.fireActivation(Creshendo.Util.Rete.IActivation)">
            <summary>
            method is used to fire an activation immediately
            </summary>
            <param name="act">The act.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.addModule(System.String)">
            <summary>
            Adds the module.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.addModule(System.String,System.Boolean)">
            <summary>
            Adds the module.
            </summary>
            <param name="name">The name.</param>
            <param name="setfocus">if set to <c>true</c> [setfocus].</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.removeModule(System.String)">
            <summary>
            Removes the module.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findModule(System.String)">
            <summary>
            Finds the module.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findFunction(System.String)">
            <summary>
            Finds the function.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findTemplate(System.Type)">
            <summary>
            Method will look up the Template using the class
            </summary>
            <param name="clazz">The clazz.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findTemplate(System.String)">
            <summary>
            find the template starting with other modules and ending with the main
            module.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findQueryAdapter(Creshendo.Util.Rete.ITemplate)">
            <summary>
            Users can write query adapters to execute an external query. The method
            will find all Query adapters for a given Template. There can be zero or
            more adapter registered for a given template. If the template hasn't been
            defined, the method return null.
            </summary>
            <param name="template">The template.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.registerQueryAdapter(Creshendo.Util.Rete.IQuery)">
            <summary>
            Registers the query adapter.
            </summary>
            <param name="adapter">The adapter.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareObject(System.String,System.String,System.String)">
            <summary>
            Declares the object.
            </summary>
            <param name="className">Name of the class.</param>
            <param name="templateName">Name of the template.</param>
            <param name="parent">The parent.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareObject(System.Type)">
            <summary>
            Declares the object.
            </summary>
            <param name="obj">The obj.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareObject(System.Type,System.String)">
            <summary>
            Declare a class with a specific template name
            </summary>
            <param name="obj">The obj.</param>
            <param name="templateName">Name of the template.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareObject(System.Type,System.String,System.Type)">
            <summary>
            Declares the object.
            </summary>
            <param name="obj">The obj.</param>
            <param name="templateName">Name of the template.</param>
            <param name="parent">The parent.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareObject(System.Type,System.String,System.String)">
            <summary>
            Declares the object.
            </summary>
            <param name="obj">The obj.</param>
            <param name="templateName">Name of the template.</param>
            <param name="parent">-
            the parent template</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findDefclass(System.Type)">
            <summary>
            Finds the defclass.
            </summary>
            <param name="clazz">The clazz.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findDefclassByTemplate(System.String)">
            <summary>
            Finds the defclass by template.
            </summary>
            <param name="templateName">Name of the template.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.findDefclass(System.Object)">
            <summary>
            Implementation will lookup the defclass for a given object by using the
            Class as the key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareTemplate(Creshendo.Util.Rete.ITemplate)">
            <summary>
            method is specifically for templates that are declared in the shell and
            do not have a corresponding java class.
            </summary>
            <param name="temp">The temp.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareFunction(Creshendo.Functions.IFunction)">
            <summary>
            To explicitly deploy a custom function, call the method with an instance
            of the function
            </summary>
            <param name="func">The func.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareFunction(System.String,Creshendo.Functions.IFunction)">
            <summary>
            In some cases, we may want to declare a function under an alias. For
            example, Add can be alias as "+".
            </summary>
            <param name="alias">The alias.</param>
            <param name="func">The func.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareFunction(System.String)">
            <summary>
            Method will create an instance of the function and declare it. Once a
            function is declared, it can be used. All custom functions must be
            declared before they can be used.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareFunctionGroup(System.String)">
            <summary>
            Method will create in instance of the FunctionGroup class and load the
            functions.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareFunctionGroup(Creshendo.Functions.IFunctionGroup)">
            <summary>
            Method will register the function of the FunctionGroup .
            </summary>
            <param name="functionGroup">FunctionGroup with the functions to register.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.loadRuleset(System.String)">
            <summary>
            pass a filename to load the rules. The implementation uses BatchFunction
            to load the file.
            </summary>
            <param name="filename">The filename.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.loadRuleset(System.IO.Stream)">
            <summary>
            load the rules from an inputstream. The implementation uses the Batch
            function to load the input.
            </summary>
            <param name="ins">The ins.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.declareDefglobal(System.String,System.Object)">
            <summary>
            Declares the defglobal.
            </summary>
            <param name="name">The name.</param>
            <param name="value_Renamed">The value_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.getDefglobalValue(System.String)">
            <summary>
            Gets the defglobal value.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.getBinding(System.String)">
            <summary>
            The current implementation will check to see if the variable is a
            defglobal. If it is, it will return the value. If not, it will see if
            there is an active rule and try to Get the local bound value.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.setBindingValue(System.String,System.Object)">
            <summary>
            This is the main method for setting the bindings. The current
            implementation will check to see if the name of the variable begins and
            ends with "*". If it does, it will declare it as a defglobal. Otherwise,
            it will try to Add it to the rule being fired. Note: might need to have
            Add one for shell variables later.
            </summary>
            <param name="key">The key.</param>
            <param name="value_Renamed">The value_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.pushScope(Creshendo.Util.Rete.IScope)">
            <summary>
            when a rule is active, it should push itself into the scopes. when
            the rule is done, it has to pop itself out of scope. The same applies
            to interpretedFunctions.
            </summary>
            <param name="s">The s.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.popScope">
            <summary>
            pop a scope out of the stack
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.getShadowFact(System.Object)">
            <summary>
            Get the shadow for the object
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.getFactById(System.Int64)">
            <summary>
            changed the implementation so it searches for the fact by id.
            Starting with the HashMap for deffact, dynamic facts and finally
            static facts.
            </summary>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.addPrintWriter(System.String,System.IO.TextWriter)">
            <summary>
            this method is for adding printwriters for spools. the purpose of
            the spool function is to dump everything out to a file.
            </summary>
            <param name="name">The name.</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.removePrintWriter(System.String)">
            <summary>
            It is up to spool function to make sure it removes the printer
            writer and closes it properly.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.writeMessage(System.String)">
            <summary>
            The method is called by classes to write watch, profiling and other
            messages to the output stream. There maybe 1 or more outputstreams.
            </summary>
            <param name="msg">The MSG.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.writeMessage(System.String,System.String)">
            <summary>
            writeMessage will create a MessageEvent and pass it along to any
            channels. It will also write out all messages to all registered
            PrintWriters. For example, if there's a spool setup, it will write
            the messages to the printwriter.
            </summary>
            <param name="msg">The MSG.</param>
            <param name="output">The output.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.writeMessage(Creshendo.Util.Rete.BaseNode)">
            <summary>
            The method will print out the node. It is up to the method to check if
            pretty printer is true and call the appropriate node method to Get the
            string.
            TODO - need to implement this
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.assertEvent(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.IFact)">
            <summary>
            Method will process the retractEvent, preferably with an event queue
            </summary>
            <param name="node">The node.</param>
            <param name="fact">The fact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.assertEvent(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.IFact[])">
            <summary>
            Asserts the event.
            </summary>
            <param name="node">The node.</param>
            <param name="facts">The facts.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.retractEvent(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.IFact)">
            <summary>
            Method will process the retractEvent, referably using an event queue
            </summary>
            <param name="node">The node.</param>
            <param name="fact">The fact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.retractEvent(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.IFact[])">
            <summary>
            Retracts the event.
            </summary>
            <param name="node">The node.</param>
            <param name="facts">The facts.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.assertObject(System.Object,System.String,System.Boolean,System.Boolean)">
            <summary>
            the method calls WorkingMemory.assertObject
            </summary>
            <param name="data">The data.</param>
            <param name="template">The template.</param>
            <param name="statc">if set to <c>true</c> [statc].</param>
            <param name="shadow">if set to <c>true</c> [shadow].</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.assertObjects(System.Collections.IList)">
            <summary>
            By default assertObjects will assert with shadow and dynamic. It also
            assumes the classes aren't using an user defined template name.
            </summary>
            <param name="objs">The objs.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.retractObject(System.Object)">
            <summary>
            Retracts the object.
            </summary>
            <param name="data">The data.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.modifyObject(System.Object)">
            <summary>
            Modify will call retract with the old fact, followed by updating the fact
            instance and asserting the fact.
            </summary>
            <param name="data">The data.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.assertFact(Creshendo.Util.Rete.Deffact)">
            <summary>
            This method is explicitly used to assert facts.
            </summary>
            <param name="fact">The fact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.retractById(System.Int64)">
            <summary>
            retract by fact id is slower than retracting by the deffact instance. the
            method will find the fact and then call retractFact(Deffact)
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.retractFact(Creshendo.Util.Rete.Deffact)">
            <summary>
            Retract a fact directly
            </summary>
            <param name="fact">The fact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.modifyFact(Creshendo.Util.Rete.Deffact,Creshendo.Util.Rete.Deffact)">
            <summary>
            Modify retracts the old fact and asserts the new fact. Unlike assertFact,
            modifyFact will not check to see if the fact already exists. This is
            because the old fact would already be unique.
            </summary>
            <param name="old">The old.</param>
            <param name="newfact">The newfact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.resetAll">
            <summary>
            Method will call resetObjects first, followed by resetFacts.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.resetObjects">
            <summary>
            Method will retract the objects and re-assert them. It does not reset the
            deffacts.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.resetFacts">
            <summary>
            Method will retract all the deffacts and then re-assert them. Reset does
            not reset the objects. To reset both the facts and objects, call
            resetAll. resetFacts handles deffacts which are not derived from objects.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.nextFactId">
            <summary>
            This is temporary, it should be replaced with something like the current
            factHandleFactory().newFactHandle()
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.nextNodeId">
            <summary>
            return the Current rete node id for a new node
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.peakNextNodeId">
            <summary>
            peak at the Current node id. Do not use this method to Get an id for the
            Current node. only nextNodeId() should be used to create new rete nodes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.printWorkingMemory(System.Boolean,System.Boolean)">
            <summary>
            Prints the working memory.
            </summary>
            <param name="detailed">if set to <c>true</c> [detailed].</param>
            <param name="inputNodes">if set to <c>true</c> [input nodes].</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.propertyChange(Creshendo.Util.PropertyChangeEvent)">
            <summary>
            not implemented yet
            </summary>
            <param name="event_Renamed">The event_ renamed.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.PropertyHasChanged(System.Object,Creshendo.Util.PropertyChangedHandlerEventArgs)">
            <summary>
            Properties the has changed.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:Creshendo.Util.PropertyChangedHandlerEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.addEngineEventListener(Creshendo.Util.Rete.EngineEventListener)">
            <summary>
            Add a listener if it isn't already a listener
            </summary>
            <param name="listen">The listen.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Rete.removeEngineEventListener(Creshendo.Util.Rete.EngineEventListener)">
            <summary>
            Remove a listener
            </summary>
            <param name="listen">The listen.</param>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.CurrentFocus">
            <summary> Method returns the current focus. Only the rules in the current focus
            will be fired. Activations in other modules will not be fired until the
            focus is changed to it.
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Defclasses">
            <summary> Return a Set of the declass instances
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.FunctionGroups">
            <summary> Returns a list of the function groups. If a function is not in a group,
            Get the complete list of functions using getAllFunctions instead.
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.AllFunctions">
            <summary> Returns a collection of the function instances
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Focus">
            <summary>
            set the focus to a different module
            </summary>
            <value>The focus.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Watch">
            <summary>
            Rete class Contains a list of items that can be watched. Call the method
            with one of the four types:<br/> activations<br/> all<br/> facts<br/>
            rules<br/>
            </summary>
            <value>The watch.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.UnWatch">
            <summary>
            Call the method with the type to unwatch activations<br/> facts<br/>
            rules<br/>
            </summary>
            <value>The un watch.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Profile">
            <summary>
            To turn on profiling, call the method with the appropriate parameter. The
            parameters are defined in Rete class as static int values.
            </summary>
            <value>The profile.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.ProfileOff">
            <summary>
            To turn off profiling, call the method with the appropriate parameter.
            The parameters are defined in Rete class as static int values.
            </summary>
            <value>The profile off.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.AllFacts">
            <summary>
            return a list of all the facts including deffacts and shadow of objects
            </summary>
            <value>All facts.</value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Objects">
            <summary>
            Return a list of the objects asserted in the working memory
            </summary>
            <value>The objects.</value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Deffacts">
            <summary>
            Return a list of all facts which are not shadows of Objects.
            </summary>
            <value>The deffacts.</value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.DeffactCount">
            <summary> return just the number of deffacts
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.RulesFired">
            <summary>
            Method returns a list of the rules that fired
            </summary>
            <value>The rules fired.</value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Agenda">
            <summary>
            Gets the agenda.
            </summary>
            <value>The agenda.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.RuleCompiler">
            <summary>
            Gets the rule compiler.
            </summary>
            <value>The rule compiler.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.WorkingMemory">
            <summary>
            Gets the working memory.
            </summary>
            <value>The working memory.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.Strategy">
            <summary>
            Gets the strategy.
            </summary>
            <value>The strategy.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.ActivationList">
            <summary>
            Gets the activation list.
            </summary>
            <value>The activation list.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.ObjectCount">
            <summary>
            Gets the object count.
            </summary>
            <value>The object count.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.Rete.ValidateRules">
            <summary>
            Gets or sets a value indicating whether [validate rules].
            </summary>
            <value><c>true</c> if [validate rules]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Creshendo.Functions.ProfileFunction">
            <author>  Peter Lin
            *
            ProfileFunction is used to turn on profiling. It provides basic
            profiling of assert, retract, Add activation, Remove activation
            and fire.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ProfileFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.PredicateConstraint">
            <author>  Peter Lin
            *
            Predicate constraint binds the slot and then performs some function
            on it. For example 
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rule.PredicateConstraint.functionName">
            <summary> the name of the function
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.PredicateConstraint.name">
            <summary> the name of the slot
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.PredicateConstraint.varName">
            <summary> the name of the variable
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.PredicateConstraint.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.PredicateConstraint.normalize">
            <summary> the purpose of normalize is to look at the order of the
            parameters and flip the operator if necessary
            *
            </summary>
        </member>
        <member name="T:Creshendo.Functions.PPrintRuleFunction">
            <author>  Peter Lin
            
            The function will print out the rule in a pretty format. Note the
            format may not be identicle to what the user wrote. It is a normalized
            and cleaned up format.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.PPrintRuleFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.OrderedFactTypeNode">
            <summary> OrderedFactTypeNode is the object type node for ordered facts. The
            difference between the two is this type node is used only for
            ordered facts. Jamocha groups the ordered facts by the number of slots
            first. The second thing is it uses a HashMap for the successors, since
            the first slot in the ordered fact is a symbol. This means it is always
            an equality test, which means we shouldn't iterate over all successors.
            The class should just look it up and only propogate to the one node.
            </summary>
            <author>  Peter Lin
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.OrderedFactTypeNode.deftemplate">
            <summary> The Class that defines object type
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.OrderedFactTypeNode.entries">
            <summary> HashMap entries for unique AlphaNodes
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.OrderedFactTypeNode.#ctor(System.Int32,Creshendo.Util.Rete.ITemplate)">
            <param name="">id
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Rete.NoMemAnd">
            <author>  Peter Lin
            *
            AlphaNodeMS is similar to AlphaNode. The main difference is AlphaNode2
            is for comparing a slot against multiple values with equal/not equal
            operator.
            <br/>
            Although there is a class called Alpha memory, Alpha nodes use a
            simple org.jamocha.rete.util.IList to remember which facts matched. A decision was made to
            use a simple org.jamocha.rete.util.List, since assert only takes a single Fact object.
            If we change assert to take an array of facts, we would need to
            replace the List with a map of AlphaMemory.<br/>
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.NoMemAnd.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.NoMemAnd.useCount">
            <summary> The useCount is used to keep track of how many times
            an Alpha node is shared. This is needed so that we
            can dynamically Remove a rule at run time and Remove
            the node from the network. If we didn't keep count,
            it would be harder to figure out if we can Remove the node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.incrementUseCount">
            <summary> every time the node is shared, the method
            needs to be called so we keep an accurate count.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.decrementUseCount">
            <summary> every time a rule is removed from the network
            we need to decrement the count. Once the count
            reaches zero, we can Remove the node by calling
            it's finalize.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation will first check to see if the fact already matched.
            If it did, the fact stops and doesn't go any further. If it doesn't,
            it will attempt to evaluate it and Add the fact if it matches.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract a fact from the node
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.evaluate(Creshendo.Util.Rete.IFact)">
            <summary> evaluate the node's value against the slot's value. The method
            uses Evaluate class to perform the evaluation
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.hashString">
            <summary> method returns toString() for the hash
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.ToString">
            <summary> Method returns the string format of the node's condition. later on
            this should be cleaned up.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemAnd.toPPString">
            <summary> Method returns the pretty printer formatted string of the node's
            condition. For now, the method just replaces the operator. It might
            be nice to replace the slot id with the slot name.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemAnd.Shared">
            <summary> the first time the RETE compiler makes the node shared,
            it needs to increment the useCount.
            </summary>
            <param name="">share
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemAnd.Slot">
            <summary> Set the slot id. The slot id is the deftemplate slot id
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemAnd.UseCount">
            <summary> return the times the node is shared
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemAnd.Operator">
            <summary> method is not implemented, since it doesn't apply
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NoAgendaTNode2">
            <author>  Peter Lin
            *
            NoAgendaTNode2 is similar to NoAgendaTNode with one difference. The rule
            may be deploy, but isn't effective until a given time. The terminal node
            will only create the activation if the current time is between the effective
            and expiration date of the rule.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.NoAgendaTNode">
            <author>  Peter Lin
            *
            NoAgendaTNode is different than TerminalNode2 in that it doesn't
            Get added to the agenda. Instead, it fires immediately.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.#ctor(System.Int32,Creshendo.Util.Rule.IRule)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.NoAgendaTNode"/> class.
            </summary>
            <param name="id"></param>
            <param name="rl"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            method does not apply for no agenda terminal node
            </summary>
            <param name="mem"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.assertFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            </summary>
            <param name="inx"></param>
            <param name="engine"></param>
            <param name="mem"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.retractFacts(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            method does not apply, since the activation fires immediately,
            there's nothing to Remove from the agenda
            </summary>
            <param name="facts">The facts.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.removeActivation(Creshendo.Util.Rete.IWorkingMemory,Creshendo.Util.Rete.LinkedActivation)">
            <summary>
            method doesn't apply for no agenda terminal node
            </summary>
            <param name="mem"></param>
            <param name="activation"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.ToString">
            <summary>
            return the name of the rule
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode.toPPString">
            <summary>
            return the name of the rule
            </summary>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.NoAgendaTNode.Rule">
            <summary>
            Return the Rule object associated with this terminal node
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode2.#ctor(System.Int32,Creshendo.Util.Rule.IRule)">
            <param name="">id
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoAgendaTNode2.assertFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <param name="">facts
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.ModulesFunction">
            <author>  Sebastian Reinartz
            
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.MillisecondTime">
            <author>  Peter Lin
            
            EchoFunction is used to echo variable bindings in the shell.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.MillisecondTime.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.MillisecondTime.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> The method expects an array of ShellBoundParam. The method will use
            StringBuffer to resolve the binding and print out 1 binding per
            line.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.InterpretedFunction">
            <summary> 
            </summary>
            <author>  Peter Lin
            
            </author>
        </member>
        <member name="F:Creshendo.Functions.InterpretedFunction.functionParams">
            <summary> these are the functions we pass to the top level function.
            they may be different than the input parameters for the
            function.
            </summary>
        </member>
        <member name="M:Creshendo.Functions.InterpretedFunction.#ctor(System.String,Creshendo.Util.Rete.IParameter[],Creshendo.Functions.IFunction[],Creshendo.Util.Rete.IParameter[][])">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Multiply">
            <author>  Peter Lin
            *
            TODO To change the template for this generated type comment go to
            Window - Preferences - Java - Code Style - Code Templates
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Multiply.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.FunctionParam2">
            <author>  Peter Lin
            *
            Describe difference between the Function parameters
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.FunctionParam2.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> TODO we may want to check the value type and throw and exception
            for now just getting it to work.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.ExistConditionCompiler">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 12, 2007 9:50:17 AM
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.AbstractConditionCompiler">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 16, 2007 2:22:07 PM
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.AbstractConditionCompiler.connectJoinNode(Creshendo.Util.Rule.ICondition,Creshendo.Util.Rule.ICondition,Creshendo.Util.Rete.BaseJoin,Creshendo.Util.Rete.BaseJoin)">
            <summary> The first step is to connect the exist join to the parent on the left side. 
            The second step is to connect it to the parent on the right. For the right 
            side, if the objectCondition doesn't have any nodes, we attach it to the 
            objectType node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.AbstractConditionCompiler.getBindings(Creshendo.Util.Rule.ICondition,Creshendo.Util.Rule.IRule,System.Int32)">
            <summary> the paramList should be clean and 
            other codes surrounding this method in subclass may be removed into this method.
            Houzhanbin 10/16/2007
            </summary>
            <param name="">condition
            </param>
            <param name="">rule
            </param>
            <param name="">Constraints
            </param>
            <param name="">position
            </param>
            <param name="">hasNotEqual
            </param>
            <param name="">hasPredicateJoin
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ExistConditionCompiler.compile(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule,System.Boolean)">
            <summary> Method will compile exists quantifier
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ExistConditionCompiler.compileFirstJoin(Creshendo.Util.Rule.ICondition,Creshendo.Util.Rule.IRule)">
            <summary> TODO - note the logic feels a bit messy. Need to rethink it and make it
            simpler. When the first conditional element is Exist, it can only have
            literal constraints, so we shouldn't need to check if the last node
            is a join. That doesn't make any sense. Need to rethink this and clean
            it up. Peter Lin 10/14/2007
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ExistConditionCompiler.compileJoin(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule)">
            <summary> method compiles ExistCE to an exist node. It does not include rules that
            start with Exist for the first CE.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.EchoFunction">
            <author>  Peter Lin
            
            EchoFunction is used to echo variable bindings in the shell.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.EchoFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.EchoFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> The method expects an array of ShellBoundParam. The method will use
            StringBuffer to resolve the binding and print out 1 binding per
            line.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.DefglobalMap">
            <summary> 
            </summary>
            <author>  Peter Lin
            
            The purpose of DefglobalMap is to centralize the handling of defglobals
            in a convienant class that can be serialized easily from one engine
            to another.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.DefglobalMap.variables">
            <summary> later on we should replace this and have it
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefglobalMap.declareDefglobal(System.String,System.Object)">
            <summary> The current implementation doesn't check and simply puts the
            new defglobal into the underlying HashMap
            </summary>
            <param name="">name
            </param>
            <param name="">value
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefglobalMap.getValue(System.String)">
            <summary> The current implementation calls HashMap.Get(key). if the key
            and value aren't in the HashMap, it returns null.
            </summary>
            <param name="">name
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefglobalMap.printDefglobals(Creshendo.Util.Rete.Rete)">
            <summary> Convienance method for iterating over the entries in the HashMap
            and printing it out. The implementation prints the String key and
            calls Object.toString() for the value.
            </summary>
            <param name="">engine
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Logging.Log4netLogger">
            <author>  Peter Lin
            
            A quick and simple logger. To make it easier for other classes to
            log and not have to import log4j stuff. 
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.BooleanFunctions">
            <author>  Peter Lin
            
            RuleEngineFunction is responsible for loading all the rule functions
            related to engine operation.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.BasicActivation">
            <author>  Peter Lin
            *
            The current implementation of Activation performs several steps
            1. Get a timestamp for the activation
            2. Add the timestamp for the facts
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.IActivation">
            <author>  Peter Lin
            *
            Basic interface for activation. There may be more than one implementation
            of Activation. The important thing about the activation is it knows which
            facts trigger a single rule.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivation.compare(Creshendo.Util.Rete.IActivation)">
            <summary>
            If the activation passed in the parameter has the same rule
            and facts, the method should return true
            </summary>
            <param name="act">The act.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivation.executeActivation(Creshendo.Util.Rete.Rete)">
            <summary>
            Execute the right-hand side (aka actions) of the rule.
            </summary>
            <param name="engine">The engine.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivation.toPPString">
            <summary> When watch activation is turned on, we use the method to print out
            the activation.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IActivation.clear">
            <summary> after the activation is executed, Clear has to be called.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.IActivation.AggregateTime">
            <summary> The aggregate time is the sum of the Fact timestamps
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IActivation.Facts">
            <summary> Get the Facts that triggered the rule
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IActivation.Index">
            <summary> Get the Index for the Facts
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IActivation.Rule">
            <summary> Get the rule that should fire
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="F:Creshendo.Util.Rete.BasicActivation.index">
            <summary> these are the facts that activated the rule. It's important
            to keep in mind that any combination of facts may fire a
            rule. 
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BasicActivation.timetag">
            <summary> the time tag is the time stamp of when the activation was
            created and added to the agenda.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BasicActivation.aggreTime">
            <summary> The aggregate time of the facts that triggered the rule.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BasicActivation.theRule">
            <summary> the rule to fire
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.#ctor(Creshendo.Util.Rule.IRule,Creshendo.Util.Rete.Index)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.BasicActivation"/> class.
            </summary>
            <param name="rule">The rule.</param>
            <param name="inx">The inx.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.compare(Creshendo.Util.Rete.IActivation)">
            <summary>
            Convienant method for comparing two Activations in a module's
            activation list. If the rule is the same and the index is the
            same, the method returns true. This compare method isn't meant
            to be used for strategies. It is up to strategies to compare
            two activations against each other using various criteria.
            </summary>
            <param name="act">The act.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.executeActivation(Creshendo.Util.Rete.Rete)">
            <summary>
            The purpose of the method is to execute the actions of the
            rule. The current implementation calls Rule.setTriggerFacts()
            at the start and Rule.resetTriggerFacts() at the end.
            Note: Only one activation can be executing at any given time,
            so setting the trigger facts should not be an issue. Although
            one could queue up the assert/retract/modify in the rule
            action, that can lead to undesirable results. The only edge
            case that could occur is in backward chaining mode. If the
            actions of a rule results in the activation of a backward
            rule, it is possible to have nested execution of different
            rules. Generally speaking, a rule should not result in
            infinite recursion, since that would product a Stack over flow
            in Java.
            </summary>
            <param name="engine">The engine.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.toPPString">
            <summary>
            When watch activation is turned on, we use the method to print out
            the activation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.clear">
            <summary>
            Clear will set the rule to null and call Index.Clear
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.calculateTime(Creshendo.Util.Rete.IFact[])">
            <summary>
            Calculates the time.
            </summary>
            <param name="facts">The facts.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.BasicActivation.cloneActivationList">
            <summary>
            Clones the activation list.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BasicActivation.TimeStamp">
            <summary>
            the timestamp of when the activation was created. the time is in
            nanoseconds.
            </summary>
            <value>The time stamp.</value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BasicActivation.Facts">
            <summary>
            The facts that matched the rule
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BasicActivation.Index">
            <summary>
            the index is used to compare the facts quickly
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BasicActivation.Rule">
            <summary>
            the rule that matched
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BasicActivation.AggregateTime">
            <summary>
            Return the sum of the fact timestamp triggering the rule
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.AlphaNodePredConstr">
            <author>  Peter Lin
            *
            AlphaNodePredConstr is similar to AlphaNode with the difference that
            this node calls a function. The function must return boolean type.
            In other words, the function has to evaluate to true or false.
            example of a predicate constraint:
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNodePredConstr.function">
            <summary> The function to call
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNodePredConstr.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodePredConstr.#ctor(System.Int32,Creshendo.Functions.IFunction,Creshendo.Util.Rete.IParameter[])">
            <summary> The default constructor takes a Node id and function
            </summary>
            <param name="">id
            </param>
            <param name="">func
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodePredConstr.evaluate(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete)">
            <summary> The method uses the function to evaluate the fact
            </summary>
            <param name="">factInstance
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.IWorkingMemory">
            <author>  Peter Lin
            *
            Interface defining working memory, which Contains all HashMaps and data structures
            related to the node memories, profiling, binding and scopes.
            
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.assertFact(Creshendo.Util.Rete.IFact)">
            ----- assert and retract methods ----- ///
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.addModule(System.String)">
            ----- methods related to module ----- ///
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.getAlphaMemory(System.Object)">
            <summary>
            The key for looking up the memory should be the node. Each node
            should pass itself as the key for the lookup.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
            -----  methods for getting the memory for a given node ----- ///
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.removeAlphaMemory(System.Object)">
            <summary>
            In the case of AlphaMemory, during the compilation process,
            we may want to Remove an alpha memory if one already exists.
            This depends on how rule compilation works.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.getBetaLeftMemory(System.Object)">
            <summary>
            The key for the lookup should be the node. Each BetaNode has
            a left and right memory, so it's necessary to have a lookup
            method for each memory.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.getBetaRightMemory(System.Object)">
            <summary>
            The key for the lookup should be the node. Each BetaNode has
            a left and right memory, so it's necessary to have a lookup
            method for each memory.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.getTerminalMemory(System.Object)">
            <summary>
            The for the lookup is the terminalNode. Depending on the terminal
            node used, it may not have a memory.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.printWorkingMemory(System.Boolean,System.Boolean)">
            <summary>
            Printout the working memory. If the method is called with
            true, the workingmemory should print out the number of
            matches for each node. It isn't necessary to print the full
            detail of each fact in each node. For now, just the number
            of matches for each Node is sufficient.
            </summary>
            <param name="detailed">if set to <c>true</c> [detailed].</param>
            <param name="inputNodes">if set to <c>true</c> [input nodes].</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.printWorkingMemory(Creshendo.Util.Collections.IGenericMap{System.Object,System.Object})">
            <summary>
            Printout the working memory with the given filter. if no filer
            is passed, it should call printWorkingMemory(true,false);
            </summary>
            <param name="filter">The filter.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.printWorkingMemoryBetaRight">
            <summary> Printout the facts on the right side of BetaNodes.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IWorkingMemory.clear">
            <summary> Clears everything in the working memory
            *
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.IWorkingMemory.RuleCompiler">
            <summary> Return the RuleCompiler for this working memory
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rule.TestCondition">
            <author>  Peter Lin
            *
            A TestCondition is a pattern that uses a function. For example,
            in CLIPS, (test (> ?var1 ?var2) )
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.TestCondition.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.TestCondition.addNode(Creshendo.Util.Rete.BaseNode)">
            <summary> The current implementation checks to make sure the node is a
            TestNode. If it is, it will set the node. If not, it will ignore
            it.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.TestCondition.Nodes">
            <summary>
            the current implementation creates a new org.jamocha.rete.util.List, adds the
            TestNode to it and returns the list.
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rule.TestCondition.BindConstraints">
            <summary> return an org.jamocha.rete.util.IList of the bindings. in the case of TestCondition, the
            bindings are BoundParam
            </summary>
        </member>
        <member name="T:Creshendo.Functions.PPrintNodeFunction">
            <author>  Peter Lin
            
            The function will print out the rule in a pretty format. Note the
            format may not be identicle to what the user wrote. It is a normalized
            and cleaned up format.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.PPrintNodeFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.PPrintNodeFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> TODO - I need to finish this, so it can print out a node
            in a pretty format
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.OrLiteralConstraint">
            <author>  Peter Lin
            *
            Literal constraint is a comparison between an object field and a concrete
            value. for example, account.name is equal to "Peter Lin". I originally,
            named the class something else, but since CLIPS uses literal constraint,
            I decided to change the name of the class. Even though I don't like the
            term literal constraint, it doesn't make sense to fight existing
            terminology.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.OrLiteralConstraint.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.OrLiteralConstraint.Negated">
            <summary> if the literal constraint is negated, the method returns true
            </summary>
            <returns>
            
            </returns>
            <summary> if the literal constraint is negated with a "~" tilda, call
            the method pass true.
            </summary>
            <param name="">negate
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.OrLiteralConstraint.Name">
            <summary> the name is the slot name
            </summary>
            <summary> set the slot name as declared in the rule
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.OrLiteralConstraint.Value">
            <summary> Set the value of the constraint. It should be a concrete value and
            not a binding.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NotJoin">
            <author>  Peter Lin
            
            NotJoin is used for Negated Conditional Elements. It is similar to
            BetaNode with a few important differences. When facts enter through
            the right side, it can only result in retracting facts from
            successor nodes and removal of activations from the agenda.
            Retracting facts from the right can only result in propogating
            facts down the RETE network. The node will only propogate when
            the match count goes from 1 to zero. Removing activations only
            happens when the match count on the left goes from zero to one. 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="linx">The linx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an
            Alpha node.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left is different than retractRight for couple
            of reasons.
            <ul>
            <li> NotJoin will only propogate the facts from the left</li>
            <li> NotJoin never needs to merge the left and right</li>
            </ul>
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="rfact">The rfact.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.evaluate(Creshendo.Util.Rete.IFact,System.Int32,Creshendo.Util.Rete.IFact,System.Int32,System.Int32)">
            <summary> Method will evaluate a single slot from the left against the right.
            </summary>
            <param name="">left
            </param>
            <param name="">leftId
            </param>
            <param name="">right
            </param>
            <param name="">rightId
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.addSuccessorNode(Creshendo.Util.Rete.TerminalNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> NotJoin has to have a special addSuccessorNode since it needs
            to just propogate the left facts if it has zero matches.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.ToString">
            <summary> TODO implement this to return the bind info
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoin.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Util.Messagerouter.MessageEventArgs">
            <summary> The Class for MessageEvents.
            
            </summary>
            <author>  Alexander Wilden, Christoph Emonds, Sebastian Reinartz
            
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.AbstractMessageEventArgs">
            <author>  Peter Lin
            
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.AbstractMessageEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.AbstractMessageEventArgs"/> class.
            </summary>
            <param name="channelId">The channel id.</param>
        </member>
        <member name="P:Creshendo.Util.Rete.AbstractMessageEventArgs.ChannelId">
            <summary> Returns the id of the sender of the message.
            
            </summary>
            <returns> The sender-id
            
            </returns>
        </member>
        <member name="F:Creshendo.Util.Messagerouter.MessageEventArgs.message">
            <summary> The message that was send.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Messagerouter.MessageEventArgs.#ctor(Creshendo.Util.Rete.EventType,System.Object,System.String)">
            <summary>
            The constructor for a new MessageEvent. Uses CLIPS as standard-language.
            </summary>
            <param name="type">The type.</param>
            <param name="message">The message.</param>
            <param name="channelId">The channel id.</param>
        </member>
        <member name="P:Creshendo.Util.Messagerouter.MessageEventArgs.Message">
            <summary> Returns the message of this event
            
            </summary>
            <returns> The message
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.Index">
            <author>  Peter Lin<p/>
            *
            Index is used for the Alpha and BetaMemories for the index. Instead of the
            original quick and dirty String index implementation, this implementation
            takes an Array of Fact[] objects and calculates the hash.
            The class overrides GetHashCode and Equals(Object) so that it works correctly
            as the key for HashMaps. There is an unit test called IndexTest in the
            test directory.
            
            The implementation for now is very simple. Later on, we may need to update
            it and make sure it works for memory snapshots and other features.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.#ctor(Creshendo.Util.Rete.IFact[])">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.Index"/> class.
            </summary>
            <param name="facts">The facts.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.#ctor(Creshendo.Util.Rete.IFact[],System.Int32)">
            <summary>
            constructor takes facts and a new hashcode. it expects the
            hashcode to be correct.
            </summary>
            <param name="facts">The facts.</param>
            <param name="hashCode">The hash code.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.Equals(System.Object)">
            <summary>
            The implementation is very close to Drools FactHandleList implemented
            by simon. The main difference is that Drools uses interfaces and
            Sumatra doesn't. I don't see a need to abstract this out to an
            interface, since no one other than an experience rule engine
            developer would be writing a new Index class. And even then, it only
            makes sense to replace the implementation. Having multiple index
            implementations doesn't really make sense.
            </summary>
            <param name="val">The val.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.GetHashCode">
            <summary>
            Method simply returns the cached GetHashCode.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.toPPString">
            <summary>
            Return a pretty print formatted String.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.calculateHash">
            <summary>
            This is a very simple implementation that basically adds the hashCodes
            of the Facts in the array.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.clear">
            <summary>
            Clear the index
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.add(Creshendo.Util.Rete.IFact)">
            <summary>
            Adds the specified fact.
            </summary>
            <param name="fact">The fact.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Index.addAll(Creshendo.Util.Rete.Index)">
            <summary>
            Adds all.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Index.Facts">
            <summary>
            this method should be refactored,so that we couldn't change the value of the memeber vairable facts
            Houzhanbin 10/25/2007
            </summary>
            <value>The facts.</value>
            <returns>
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.HashedEqBNode">
            <author>  Peter Lin
            
            HashedBetaNode indexes the right input to improve cross product performance.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be joining
            against one or more objects, we need to pass all previously matched
            facts.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an Alpha node.
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left requires that we propogate the
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order. 1. Remove the fact
            from the right memory 2. check which left memory matched 3. propogate the
            retract
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> Method will use the right binding to perform the evaluation of the join.
            Since we are building joins similar to how CLIPS and other rule engines
            handle it, it means 95% of the time the right fact list only has 1 fact.
            
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.ToString">
            <summary> Basic implementation will return string format of the betaNode
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedEqBNode.toPPString">
            <summary> returns the node named + node id and the bindings in a string format
            </summary>
        </member>
        <member name="T:Creshendo.Functions.EqFunction">
            <author>  Peter Lin
            
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.EqFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.BindValue">
            <author>  Peter Lin
            
            this class is used by hash not equal beta node. It uses to create
            the Hash index to look up the matches on the right.
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.AssertTemporalFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.AssertTemporalFunction.Parameter">
            <summary> The expected parameter is a deffact instance. According to CLIPS
            beginner guide, assert only takes facts and returns the id of the
            fact. For objects, there's (assert-object ?binding).
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.AlphaNodeAnd">
            <author>  Peter Lin
            *
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNodeAnd.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNodeAnd.useCount">
            <summary> The useCount is used to keep track of how many times
            an Alpha node is shared. This is needed so that we
            can dynamically Remove a rule at run time and Remove
            the node from the network. If we didn't keep count,
            it would be harder to figure out if we can Remove the node.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.incrementUseCount">
            <summary> every time the node is shared, the method
            needs to be called so we keep an accurate count.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.decrementUseCount">
            <summary> every time a rule is removed from the network
            we need to decrement the count. Once the count
            reaches zero, we can Remove the node by calling
            it's finalize.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation will first check to see if the fact already matched.
            If it did, the fact stops and doesn't go any further. If it doesn't,
            it will attempt to evaluate it and Add the fact if it matches.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract a fact from the node
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.evaluate(Creshendo.Util.Rete.IFact)">
            <summary> evaluate the node's value against the slot's value. The method
            uses Evaluate class to perform the evaluation
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.hashString">
            <summary> method returns toString() for the hash
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.ToString">
            <summary> Method returns the string format of the node's condition. later on
            this should be cleaned up.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNodeAnd.toPPString">
            <summary> Method returns the pretty printer formatted string of the node's
            condition. For now, the method just replaces the operator. It might
            be nice to replace the slot id with the slot name.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeAnd.Shared">
            <summary> the first time the RETE compiler makes the node shared,
            it needs to increment the useCount.
            </summary>
            <param name="">share
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeAnd.Slot">
            <summary> Set the slot id. The slot id is the deftemplate slot id
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeAnd.UseCount">
            <summary> return the times the node is shared
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNodeAnd.Operator">
            <summary> method is not implemented, since it doesn't apply
            </summary>
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.CLIPSParser.bindingParams(System.Collections.ArrayList)">
            bindingParams is meant to parse the params for a deffunction
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.CLIPSParser.getIdentifier">
            this is for convienance
        </member>
        <member name="T:Creshendo.Functions.TestRuleFunction">
            <author>  Peter Lin
            *
            ClearFunction will call Rete.Clear()
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.TestRuleFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.TestRuleFunction.Parameter">
            <summary> The function does not take any parameters
            </summary>
        </member>
        <member name="T:Creshendo.Functions.GenerateFactsFunction">
            <author>  Peter Lin
            *
            Generate facts will call the utility class with the Rule object
            and return an Object[] array of facts. Depending on the rule,
            there should be one or more deffacts or object instances. The way
            to use this is to bind the result or Add it to a list.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.GenerateFactsFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.GenerateFactsFunction.Parameter">
            <summary> The function does not take any parameters
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.ErrorSummary">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.ErrorSummary.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Const">
            <author>  Nikolaus Koemm
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Const.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.AssertFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.AssertFunction.Parameter">
            <summary> The expected parameter is a deffact instance. According to CLIPS
            beginner guide, assert only takes facts and returns the id of the
            fact. For objects, there's (assert-object ?binding).
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.TerminalNode3">
            <author>  Peter Lin
            *
            TerminalNode3 is for rules that have an effective and expiration date.
            When rules do not have it set, we don't bother checking. If it does, we
            make sure a new activation is added only if the rule is within the
            the two dates.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode3.#ctor(System.Int32,Creshendo.Util.Rule.IRule)">
            <param name="">id
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode3.assertFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> The implementation checks to see if the rule is active before it tries to
            assert the fact. It checks in the following order.
            1. is the expiration date greater than zero
            2. is the current time > the effective date
            3. is the current time the expiration date
            </summary>
            <param name="">facts
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.TerminalNode3.retractFacts(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> The implementation checks to see if the rule is active before it tries to
            retract the fact. It checks in the following order.
            1. is the expiration date greater than zero
            2. is the current time > the effective date
            3. is the current time the expiration date
            </summary>
            <param name="">facts
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.TemporalConditionCompiler">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 12, 2007 9:42:15 AM
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.ObjectConditionCompiler">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 12, 2007 9:42:15 AM
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ObjectConditionCompiler.compile(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule,System.Boolean)">
            <summary> Compile a single ObjectCondition and create the alphaNodes and/or Bindings
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ObjectConditionCompiler.attachAlphaNode(Creshendo.Util.Rete.BaseAlpha,Creshendo.Util.Rete.BaseAlpha,Creshendo.Util.Rule.ICondition)">
            <summary>
            For now just attach the node and don't bother with node sharing
            </summary>
            <param name="existing">- an existing node in the network. it may be
            an ObjectTypeNode or AlphaNode</param>
            <param name="alpha">The alpha.</param>
            <param name="cond">The cond.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ObjectConditionCompiler.shareAlphaNode(Creshendo.Util.Rete.BaseAlpha,Creshendo.Util.Rete.BaseAlpha)">
            <summary>
            Implementation will Get the hashString from each node and compare them
            </summary>
            <param name="existing">The existing.</param>
            <param name="alpha">The alpha.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ObjectConditionCompiler.compileFirstJoin(Creshendo.Util.Rule.ICondition,Creshendo.Util.Rule.IRule)">
            <summary>
            Compiles the first join.
            </summary>
            <param name="condition">The condition.</param>
            <param name="rule">The rule.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.ObjectConditionCompiler.compileJoin(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule)">
            <summary> method compiles ObjectConditions, which include NOTCE
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Compiler.TemporalConditionCompiler.compile(Creshendo.Util.Rule.ICondition,System.Int32,Creshendo.Util.Rule.IRule,System.Boolean)">
            <summary> Compile a single ObjectCondition and create the alphaNodes and/or Bindings
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.TemporalCondition">
            <author>  Peter Lin
            *
            TemporalCondition extends AbstractCondition and adds 2 additional
            attributes: relativeTime and varname. Since all temporal nodes have
            to have both, we make it easier to set and Get.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.TemporalCondition.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.TemporalCondition.compare(Creshendo.Util.Rule.ICondition)">
            <summary> TODO - currently we don't need it and it isn't implemented.
            should finish implementing it.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.TemporalCondition.toPPString">
            <summary> The current implementation expects the deffact or object binding
            constriant to be first.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Sqrt">
            <author>  Nikolaus Koemm
            
            Sqrt returns the square root value of a double value.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Sqrt.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.NeqFunction">
            <author>  Nikolaus Koemm
            
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.NeqFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.LinkedActivation">
            <author>  Peter Lin
            *
            LinkedActivation is different than BasicActivation in a couple of
            ways. LinkedActivation makes it easier to Remove Activations from
            an ActivationList, without having to iterate over the activations.
            When the activation is executed or removed, it needs to make sure
            it checks the previous and Current and set them correctly.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.#ctor(Creshendo.Util.Rule.IRule,Creshendo.Util.Rete.Index)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.LinkedActivation"/> class.
            </summary>
            <param name="rule">The rule.</param>
            <param name="inx">The inx.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.compare(Creshendo.Util.Rete.IActivation)">
            <summary>
            If the activation passed in the parameter has the same rule
            and facts, the method should return true
            </summary>
            <param name="act">The act.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.executeActivation(Creshendo.Util.Rete.Rete)">
            <summary>
            Execute the right-hand side (aka actions) of the rule.
            </summary>
            <param name="engine">The engine.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.clear">
            <summary>
            after the activation is executed, Clear has to be called.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.toPPString">
            <summary>
            When watch activation is turned on, we use the method to print out
            the activation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.calculateTime(Creshendo.Util.Rete.IFact[])">
            <summary>
            Calculates the time.
            </summary>
            <param name="facts">The facts.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.remove">
            <summary>
            Remove the Activation from the list and set the previous
            and Current activation correctly. There's basically 3 cases
            we have to handle.
            1. first
            2. last
            3. somewhere in between
            The current implementation will first set the previous
            and Current. Once they are correctly set, it will set
            the references to those LinkedActivation to null.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.remove(Creshendo.Util.Rete.Rete)">
            <summary>
            method is used to make sure the activation is removed from
            TerminalNode2.
            </summary>
            <param name="engine">The engine.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivation.cloneActivation">
            <summary>
            Clones the activation.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.Previous">
            <summary>
            the method will set the previous activation to the one
            passed to the method and it will also set previous.Current
            to this instance.
            </summary>
            <value>The previous.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.Next">
            <summary>
            the method will set the Current activation to the one
            passed to the method and it will set Current.prev to
            this instance.
            </summary>
            <value>The next.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.TerminalNode">
            <summary>
            Gets or sets the terminal node.
            </summary>
            <value>The terminal node.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.AggregateTime">
            <summary>
            The aggregate time is the sum of the Fact timestamps
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.Facts">
            <summary>
            Get the Facts that triggered the rule
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.Index">
            <summary>
            Get the Index for the Facts
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.LinkedActivation.Rule">
            <summary>
            Get the rule that should fire
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="T:Creshendo.Util.IEntry">
            <author>  pete
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.Math.Ceil">
            <author>  Nikolaus Koemm
            
            Ceil returns the smallest integer bigger or equal to a value.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Ceil.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Binding2">
            <author>  Peter Lin
            
            Binding2 is used for bindings that are are numeric comparison like
            
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.Binding">
            <author>  Peter Lin
            *
            A binding can be an object or a field of a given object. When binding
            is an Object binding, the column id will not be set. The binding
            would be the row for the left memory.
            It is up to classes using the binding to check if it is an object
            binding and Get the appropriate fact using getLeftRow().
            One thing about the current design is the binding is position based.
            The benefit is it avoids having to set the binding and reset it
            multiple times. BetaNodes use the binding to Get the correct slot
            value and use it to evaluate an atomic condition. A significant
            downside of this approach is when deftemplates are re-declared at
            runtime. It means that we might need to recompute the bindings, which
            could be a very costly process. More thought and research is needed
            to figure out the best way to handle re-declaring deftemplates.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.isObjVar">
            <summary> if the binding is to an object, the field should
            be true. by default it is false.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.isPredJoin">
            <summary> if the join is a predicate join with a function, the
            binding should be set to isPredicate
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.leftIndex">
            <summary> The indexes of the left deftemplate
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.leftrow">
            <summary> by default the row index is -1, which means
            it's not set. Any index that is negative indicates
            it's not set.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.negated_Renamed_Field">
            <summary> by default bindings test for equality. in some cases
            they test for inequality.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.rightIndex">
            <summary> the indexes for the right deftemplate
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.rowDeclared_Renamed_Field">
            <summary> We need this to keep track of which CE is the first to declare
            a binding. This is important to rule compilation.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Binding.varName">
            <summary> This is the name of the variable. Every binding must
            have a variable name. It can be user defined or auto-
            generated by the rule compiler.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Binding.Clone">
            <summary> convienance method for clonging a binding at rule compilation
            time.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Binding.rowDeclared">
            <summary> The row that declares the binding the first time. The
            row corresponds directly to the Conditional Element in
            the rule. If the second CE declares the binding for the
            first time, the row would be 1. 
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Binding.negated">
            <summary> by default bindings are not negated. if it is,
            method return true.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Binding.toBindString">
            <summary> Since the binding refers to the row and column, the binding
            doesn't know the deftemplate.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Binding.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> evaluate will extra the values from each side and evaluate it
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.VarName">
            <summary> Return the name of the variable
            </summary>
            <returns>
            
            </returns>
            <summary> Set the variable name. This is important, since the join
            nodes will use it at runtime.
            </summary>
            <param name="">name
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.IsObjectVar">
            <summary> If the binding is for an object, the method returns true.
            </summary>
            <returns>
            
            </returns>
            <summary> Set whether the binding is an object binding.
            </summary>
            <param name="">obj
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.RowDeclared">
            <summary> Set the row that declares the binding
            </summary>
            <param name="">row
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.LeftRow">
            <summary> Return the left Deftemplate 
            </summary>
            <returns>
            
            </returns>
            <summary> Set the left deftemplate
            </summary>
            <param name="">temp
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.LeftIndex">
            <summary> Get the left index
            </summary>
            <returns>
            
            </returns>
            <summary> set the left index
            </summary>
            <param name="">indx
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.RightIndex">
            <summary> Get the right index
            </summary>
            <returns>
            
            </returns>
            <summary> set the right index
            </summary>
            <param name="">indx
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Binding.Negated">
            <summary> if a binding is negated, call the method with true
            </summary>
            <param name="">neg
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Binding2.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Asin">
            <author>  Christian Ebert
            
            Returns the trigonometric arc sine of an angle.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Asin.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Acos">
            <author>  Christian Ebert
            
            Returns the trigonometric arc cosine of an angle.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Acos.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ZJBetaNode">
            <author>  Peter Lin
            
            ZJBetaNode is different than other BetaNodes in that it
            has no bindings. We optimize the performance for those
            cases by skipping evaluation and just propogate
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.ZJBetaNode.operator_Renamed">
            <summary> The operator for the join by default is equal. The the join
            doesn't comparing values, the operator should be set to -1.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="linx">The linx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Assert from the right side is always going to be from an Alpha node.
            </summary>
            <param name="rfact"></param>
            <param name="engine"></param>
            <param name="mem"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Retracting from the left requires that we propogate the
            </summary>
            <param name="linx">The linx.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="rfact"></param>
            <param name="engine"></param>
            <param name="mem"></param>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.ToString">
            <summary> Basic implementation will return string format of the betaNode
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ZJBetaNode.toPPString">
            <summary> implementation just returns the node id and the text
            zero-bind join.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.ZJBetaNode.Bindings">
            <summary>
            Set the bindings for this join
            </summary>
            <value></value>
        </member>
        <member name="T:Creshendo.Util.Rete.Strategies.Strategies">
            <summary> Strategy is where new strategies are registered and where the functions
            find the strategy class to set the strategy.
            </summary>
            <author>  woolfel
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.Math.Sin">
            <author>  Christian Ebert
            
            Returns the trigonometric sine of an angle.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Sin.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ShellBoundParam">
            <author>  Peter Lin
            *
            ShellBoundParam is meant for calling EchoFunction in the shell. It is
            different than BoundParam in a couple of ways. The first is that users
            can bind an object, fact or value. Bindings in the shell are global
            bindings.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.ShellBoundParam.valueType">
            <summary> the int value defining the valueType
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ShellBoundParam.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ShellBoundParam.resolveBinding(Creshendo.Util.Rete.Rete)">
            <summary> The method needs to be called before getting the value. First
            we need to lookup the binding.
            </summary>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ShellBoundParam.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> the class will resolve the variable with the engine
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.ShellBoundParam.Value">
            <summary> The method returns the bound object
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.ShellBoundParam.StringValue">
            <summary> if the value was null, the method returns a message "defglobal
            not found".
            </summary>
        </member>
        <member name="T:Creshendo.Functions.SaveFactsFunction">
            <author>  Peter Lin
            
            Facts function will printout all the facts, not including any
            initial facts which are internal to the rule engine.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.SaveFactsFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.RuleProperty">
            <author>  Peter Lin
            *
            Version is a generic object for version information. For now, the purpose
            is for rule version information. Since RuleML supports the notion of rule
            version and CLIPS doesn't, this is an extension.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rule.RuleProperty.DIRECTION">
            <summary> A rule can have a direction declaration. Although backward
            chaining isn't implemented yet, it's here for the future
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.RuleProperty.NO_AGENDA">
            <summary> if a rule has no-agenda set to true, it will skip the agenda
            and fire immediately.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.RuleProperty.REMEMBER_MATCH">
            <summary> The alpha memories can be explicitly turned off by the user
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.RuleProperty.SALIENCE">
            <summary> Salience defines the priority of a rule. It's a concept
            from CLIPS, ART and OPS5
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rule.RuleProperty.VERSION">
            <summary> This a rule property specific to Sumatra and is an extension
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.RuleProperty.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.RootNode">
            <author>  Peter Lin
            
            RootNode does not extend BaseNode like all other RETE nodes. This is
            done for a couple of reasons.<br/>
            <ul>
            <li> RootNode doesn't need to have a memory </li>
            <li> RootNode only has ObjectTypeNode for successors</li>
            <li> RootNode doesn't need the toPPString and other string methods</li>
            </ul>
            In the future, the design may change. For now, I've decided to keep
            it as simple as necessary.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.addObjectTypeNode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary>
            Add a new ObjectTypeNode. The implementation will check to see
            if the node already exists. It will only Add the node if it
            doesn't already exist in the network.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.removeObjectTypeNode(Creshendo.Util.Rete.ObjectTypeNode)">
            <summary> The current implementation just removes the ObjectTypeNode
            and doesn't prevent the removal. The method should be called
            with care, since removing the ObjectTypeNode can have serious
            negative effects. This would generally occur when an undeftemplate
            occurs.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.assertObject(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            assertObject begins the pattern matching
            </summary>
            <param name="fact">The fact.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.assertObjectParent(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Method will Get the deftemplate's parent and do a lookup
            </summary>
            <param name="fact">The fact.</param>
            <param name="template">The template.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.retractObject(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Retract an object from the Working memory
            </summary>
            <param name="fact">The fact.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.RootNode.retractObjectParent(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary>
            Method will Get the deftemplate's parent and do a lookup
            </summary>
            <param name="fact">The fact.</param>
            <param name="template">The template.</param>
            <param name="engine">The engine.</param>
            <param name="mem">The mem.</param>
        </member>
        <member name="P:Creshendo.Util.Rete.RootNode.ObjectTypeNodes">
            <summary> Return the HashMap with all the ObjectTypeNodes
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.Math.Pow">
            <author>  Nikolaus Koemm, Christian Ebert
            
            Returns the value of the first argument raised to the power of the following arguments.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Pow.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NSFact">
            <author>  Peter Lin
            *
            NSFact stands for Non-Shadow Fact. NSFact is different than
            Deffact which is a shadow fact for an object instance. NSFact
            should only be used for cases where fact modification isn't
            needed. In all cases where the application expects to modify
            facts in the reasoning cycle, Deffacts should be used. Using
            NSFact for situations where facts are modified or asserted
            during the reasoning cycle will produce unreliable results.
            It will violate the principle of truth maintenance, which
            means the final result is true and accurate.
            
            Cases where NSFact is useful are routing scenarios where the
            facts are filtered to determien where they should go. In
            cases like that, the consequence produces results which are
            used by the application, but aren't used by the rule engine
            for reasoning.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.NSFact.id">
            <summary> the Fact id must be unique, since we use it for the indexes
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.#ctor(Creshendo.Util.Rete.Deftemplate,Creshendo.Util.Rete.Defclass,System.Object,Creshendo.Util.Rete.Slot[],System.Int64)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.getSlotValue(System.Int32)">
            <summary> The implementation gets the Defclass and passes the 
            objectInstance to invoke the read method.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.getSlotId(System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.toFactString">
            <summary> The method will return the Fact as a string
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.updateSlots(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.Slot[])">
            <summary> Non-Shadow Fact does not implement this, since this method
            doesn't apply to facts derived from objects.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.timeStamp">
            <summary> the implementation returns nano time
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NSFact.clear">
            <summary> Clear will set all the references to null. this makes sure
            objects are GC.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.NSFact.ObjectInstance">
            <summary> The object instance for the fact
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.NSFact.FactId">
            <summary> Return the unique fact id
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.NSFact.Deftemplate">
            <summary> Return the deftemplate for the fact
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NotJoinFrst">
            <author>  Peter Lin
            
            NotJoinFrst is a special node for rules that have NOTCE for the first
            CE. The node does not propogate the initial fact down the network. 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an
            Alpha node.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left is different than retractRight for couple
            of reasons.
            <ul>
            <li> NotJoin will only propogate the facts from the left</li>
            <li> NotJoin never needs to merge the left and right</li>
            </ul>
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.evaluate(Creshendo.Util.Rete.IFact,System.Int32,Creshendo.Util.Rete.IFact,System.Int32,System.Int32)">
            <summary> Method will evaluate a single slot from the left against the right.
            </summary>
            <param name="">left
            </param>
            <param name="">leftId
            </param>
            <param name="">right
            </param>
            <param name="">rightId
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.addSuccessorNode(Creshendo.Util.Rete.TerminalNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> NotJoin has to have a special addSuccessorNode since it needs
            to just propogate the left facts if it has zero matches.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.ToString">
            <summary> TODO implement this to return the bind info
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotJoinFrst.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Functions.LoadPackageFunction">
            <author>  Christian Ebert
            
            Creates a Java Object and returns it.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.LinkedActivationList">
            <author>  Peter Lin
            *
            LinkedActivationWrapper is a container for LinkedActivation. It provdes
            the logic for modifying a org.jamocha.rete.util.LinkedList created from LinkedActivation.
            Null values are not permitted, and are silently ignored. Generally speaking,
            it doesn't make sense to Add a null activation to the agenda.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.quickSort(Creshendo.Util.Rete.LinkedActivation)">
            <summary>
            the sort method uses binary search to find the correct insertion
            point for the new activation. It's much faster than the brute
            force method.
            </summary>
            <param name="newact">The newact.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.goUp(System.Int32,Creshendo.Util.Rete.LinkedActivation)">
            <summary>
            method will loop for the given count and return the item before it.
            for example:
            1
            2
            3
            4
            5
            6
            If I pass a count of 2 and item #6. it will return #4.
            </summary>
            <param name="count">The count.</param>
            <param name="start">The start.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.goDown(System.Int32,Creshendo.Util.Rete.LinkedActivation)">
            <summary>
            method will loop for the given count and return the item after it.
            for example:
            1
            2
            3
            4
            5
            6
            If I pass a count of 2 and item #1. it will return #3.
            </summary>
            <param name="count">The count.</param>
            <param name="start">The start.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.removeActivation(Creshendo.Util.Rete.IActivation)">
            <summary> removeActivation will check to see if the activation is
            the first or last before removing it.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.contains(System.Object)">
            <summary> the current implementation iterates over the LinkedActivations
            from the start until it finds a match. If it doesn't find a
            match, the method returns false.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.clear">
            <summary> Iterate over the org.jamocha.rete.util.LinkedList and null the references to previous
            and Current in the LinkedActivation
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.indexOf(System.Object)">
            <summary> Current implemenation will return the index of the activation, if
            it is in the org.jamocha.rete.util.LinkedList. If activation isn't in the list, the method
            returns -1.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LinkedActivationList.cloneActivationList">
            <summary> method will clone the list and make a copy of the activations
            </summary>
        </member>
        <member name="T:Creshendo.Functions.IfFunction">
            <author>  Nikolaus Koemm, Christian Ebert
            
            Returns the absolute value of a double value.
            
            </author>
        </member>
        <member name="F:Creshendo.Functions.IfFunction.serialVersionUID">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.IfFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Oddp">
            <author>  Nikolaus Koemm
            
            If its ony argument is odd, Oddp returns true.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Oddp.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.EqualityIndex">
            <author>  Peter Lin<p/>
            *
            EqualityIndex is used specifically for deffacts to check if 2 facts are
            equal. By equal, we mean the values of the facts are equal.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.EqualityIndex.#ctor(Creshendo.Util.Rete.Deffact)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EqualityIndex.calculateHash">
            <summary> This is a very simple implementation that gets the slot hash from
            the deffact.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EqualityIndex.Equals(System.Object)">
            <summary> The implementation is similar to the index class.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.EqualityIndex.GetHashCode">
            <summary> Method simply returns the cached GetHashCode.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Cos">
            <author>  Christian Ebert
            
            Returns the trigonometric cosine of an angle.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Cos.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Collections.CollectionFactory">
            <author>  Peter Lin
            *
            The purpose of this factory is to centralize the creation of org.jamocha.rete.util.List,
            org.jamocha.rete.util.IList, Collection, Set and org.jamocha.rete.util.Map data structures. This is done so that
            we can easily drop in some other implementation, like Tangosol's
            Coherence product, which uses distributed HashMaps.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Collections.CollectionFactory.localMap">
            <summary> the sole purpose of this method is to return a org.jamocha.rete.util.Map that is not
            clustered. The other methods will return a map, but depending
            on the settings, they may return a org.jamocha.rete.util.Map that is hooked into a
            JCache compliant product like Tangosol's Coherence.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.AnyEqFunction">
            <author>  Peter Lin
            Any equal is used to compare a literal value against one or more
            bindings. If any of the bindings is equal to the constant value,
            the function returns true.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.AnyEqFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.ParserUtils.getStringLiteral(System.String)">
            <summary> convienant method to Get string literal
            
            </summary>
            <param name="">text
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.ParserUtils.escapeStringLiteral(System.String)">
            <summary> convienant utility method to escape string literals
            
            </summary>
            <param name="">text
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.UnDeftemplateFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.UnDeftemplateFunction.Parameter">
            <summary> The expected parameter is a single ValueParam containing a deftemplate
            instance. The function gets the deftemplate using Parameter.getValue().
            </summary>
        </member>
        <member name="T:Creshendo.Functions.StringUpperFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringUpperFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.SetFocusFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.PrintProfileFunction">
            <author>  Peter Lin
            *
            PrintProfileFunction will print out the profile information.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.PrintProfileFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NotEqHashIndex">
            <author>  Peter Lin<p/>
            *
            NotEqHashIndex is different from EqHashIndex is 2 ways. The first is
            it only uses the values of equality comparison and ignores the not
            equal values. The second is it takes BindValue[] instead of just
            Object[].
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.NotEqHashIndex.#ctor(Creshendo.Util.Rete.BindValue[])">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotEqHashIndex.Equals(System.Object)">
            <summary> The implementation is similar to the index class.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotEqHashIndex.GetHashCode">
            <summary> Method simply returns the cached GetHashCode.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NotEqHashIndex.calculateHash">
            <summary> The implementation is different than EqHashIndex. It ignores
            any Bindings that are negated
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.NotEqHashIndex.SubIndex">
            <summary> return the subindex
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.MultiSlot">
            <author>  Peter Lin
            
            MultiSlot always returns Constants.ARRAY_TYPE. It is the class for array
            types.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.MultiSlot.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.MultiSlot.Clone">
            <summary> method returns a clone and set id, name and value.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.MultiSlot.DefaultValue">
            <summary> In some cases, a deftemplate can be define with a default value.
            
            </summary>
            <param name="">value
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.MultiSlot.ValueType">
            <summary> We override the base implementation and do nothing, since a multislot is
            an object array. That means it is an array type
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.IModule">
            <author>  Peter Lin
            *
            Interface defining a module. A module may contain templates and
            rules. It is responsible for keeping track of the Activations
            and adding the activation to the list.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.addActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Add a new activation. Classes implementing the Agenda should
            check to make sure the activation is new. If it isn't new,
            don't Add it.
            </summary>
            <param name="">actv
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.addRule(Creshendo.Util.Rule.IRule)">
            <summary> Add a new rule to the module. Implementing classes may want
            to check the status of the rule engine before adding new
            rules. In the case where rules are added dynamically at
            runtime, it's a good idea to check the rule engine isn't
            busy. A important note about this method is the rule
            should already be compiled to RETE nodes. If the rule isn't
            compiled, it will not Get evaluated.
            </summary>
            <param name="">rl
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.addTemplate(Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Add a new template to the module
            </summary>
            <param name="">temp
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.clear">
            <summary> Clear will Remove all the rules, activations, and templates
            from the module.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.containsRule(Creshendo.Util.Rule.IRule)">
            <summary> Implementing classes need to keep a list of the rules, so
            that when new rules are added, the module can check to see
            if a rule with the same name already exists.
            </summary>
            <param name="">rl
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.containsTemplate(System.Object)">
            <summary> Implementing classes need to keep a list of rules, so that
            when a new template is declared, the module can check to see
            if the module already exists.
            </summary>
            <param name="">key
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.getTemplate(Creshendo.Util.Rete.Defclass)">
            <summary> Look up the template
            </summary>
            <param name="">key
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.getTemplate(System.String)">
            <summary> look up the template using a string template name
            </summary>
            <param name="">key
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.findParentTemplate(System.String)">
            <summary> Look up the parent template by the template name
            </summary>
            <param name="">key
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.removeActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Remove an activation from the activation list.
            </summary>
            <param name="">actv
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.removeRule(Creshendo.Util.Rule.IRule,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Remove a rule from the module. The method returns void, since
            the user should have found the rule they want to Remove first.
            </summary>
            <param name="">rl
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.removeTemplate(Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Remove a template from the module. The method returns void,
            since the user should have found the template first.
            </summary>
            <param name="">temp
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.findRule(System.String)">
            <summary> In the event we need to find the rule, this method will look
            up the name of the rule without the module name. Implementing
            classes may take the module + rulename for the parameter, it
            is up to the developer.
            </summary>
            <param name="">name
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IModule.nextActivation(Creshendo.Util.Rete.Rete)">
            <summary> Method will Remove the activation from the module and return it
            to the engine. The method should only be called when the RHS
            of the rule should be executed.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.ActivationCount">
            <summary> fireActivations will execute the Activations in the activation
            list. Implementing classes should make the method synchronized.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.AllActivations">
            <summary> Return a list of all the activation
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.ModuleName">
            <summary> Return the name of the module. The interface doesn't provide
            any guidelines for the format, but it is a good idea to restrict
            names without punction marks.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.Templates">
            <summary> Return the Deftemplates in a collection
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.TemplateCount">
            <summary> return the number of actual deftemplates declared
            using deftemplate or objects
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.AllRules">
            <summary> Return a list of all the rules in this module
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.RuleCount">
            <summary> Return the rule count
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.IModule.Lazy">
            <summary> To use a lazy agenda, call the method with true. To turn off
            lazy agenda, call it with false.
            </summary>
            <param name="">lazy
            
            </param>
        </member>
        <member name="T:Creshendo.Functions.MatchesFunction">
            <author>  Peter Lin
            
            MatchesFunction will print out all partial matches including alpha and 
            beta nodes.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.MatchesFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.MatchesFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> If the function is called without any parameters, it prints out
            all the memories. if parameters are passed, the output will be
            filtered.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.LIANode">
            <author>  Peter Lin
            *
            LIANode stands for Left Input Adapter Node. Left input adapter node
            can only only have 1 alphaNode above it. Left input adapater nodes are
            not shared by multiple branches of the network, so it doesn't have any
            memory.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation just propogates the assert down the network
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.propogateAssert(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Propogate the assert to the successor nodes
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract simply propogates it down the network
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.propogateRetract(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> propogate the retract
            
            </summary>
            <param name="">fact
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.addSuccessorNode(Creshendo.Util.Rete.BaseNode,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Set the Current node in the sequence of 1-input nodes.
            The Current node can be an AlphaNode or a LIANode.
            </summary>
            <param name="">node
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.ToString">
            <summary> the Left Input Adapter Node returns zero length string
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.LIANode.toPPString">
            <summary> the Left input Adapter Node returns zero length string
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.IFLIANode">
            <summary> IFLIANode is a special Left-Input Adapater node which has alpha memory.
            LIANode has no memory to make the engine more efficient, but the left
            input adapter for the InitialFact needs the memory to make sure rules
            that start with NOTCE work properly. If we don't, the user has to 
            execute (reset) function, so the rule will fire correctly.
            </summary>
            <author>  woolfel
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.IFLIANode.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation just propogates the assert down the network
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.IFLIANode.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract simply propogates it down the network
            </summary>
        </member>
        <member name="T:Creshendo.Functions.FireFunction">
            <author>  Peter Lin
            
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.FireFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Defmodule">
            <author>  Peter Lin
            *
            A module represents a set of rulesets. The concept is from CLIPS and provides
            a way to isolate the rule activation and pattern matching.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.Defmodule.activations">
            <summary> A simple org.jamocha.rete.util.IList of the activations for the given module
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Defmodule.deftemplates">
            <summary> The key is either the template name if it was created
            from the shell, or the defclass if it was created from
            an Object.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Defmodule.name">
            <summary> The name of the module. A rule engine may have one or
            more modules with rules loaded
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.Defmodule.rules">
            <summary> A simple list of the rules in this module. Before an
            activation is added to the module, the class should
            check to see if the rule is in the module first.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.#ctor(System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.addActivation(Creshendo.Util.Rete.IActivation)">
            <summary> The method should Get the agenda and use it to Add the new
            activation to the agenda
            </summary>
            <param name="">actv
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.removeActivation(Creshendo.Util.Rete.IActivation)">
            <summary> Remove an activation from the list
            </summary>
            <param name="">actv
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.nextActivation(Creshendo.Util.Rete.Rete)">
            <summary> The current implementation will Remove the first activation
            and return it. If there's no more activations, the method
            return null;
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.clear">
            <summary> When Clear is called, the module needs to Clear all the internal lists
            for rules and activations. The handle to Rete should not be nulled.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.addRule(Creshendo.Util.Rule.IRule)">
            <summary> Add a compiled rule to the module
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.removeRule(Creshendo.Util.Rule.IRule,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Remove a rule from this module
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.containsRule(Creshendo.Util.Rule.IRule)">
            <summary> If the module already Contains the rule, it will return true.
            The lookup uses the rule name, so rule names are distinct
            within a single module. The same rule name may be used in
            multiple modules.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.containsTemplate(System.Object)">
            <summary> The key is either the Defclass or a string name
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.getTemplate(Creshendo.Util.Rete.Defclass)">
            <summary> implementation looks up the template and assumes the key
            is the classname or the user define name.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.findParentTemplate(System.String)">
            <summary> find a parent template using the string template name
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.addTemplate(Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> The implementation will use either the defclass or the
            template name for the key. The templates are stored in
            a HashMap.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.removeTemplate(Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> implementation will Remove the template from the HashMap
            and it will Remove the ObjectTypeNode from the network.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defmodule.findRule(System.String)">
            <summary> implementation looks up the rule in the HashMap
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.AllActivations">
            <summary> Return all the activations within the module
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.ActivationCount">
            <summary> When the focus is changed, fireActivations should be
            called to make sure any activations in the module are
            processed.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.ModuleName">
            <summary> Return the name of the module
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.AllRules">
            <summary> implementation returns the Values of the HashMap
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.RuleCount">
            <summary> implementation returns HashMap.Count()
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.Templates">
            <summary> Method returns the entrySet of the HashMap containing the
            Deftemplates. Because of how we map the deftemplates, the
            number of entries will not correspond to the number of
            actual deftemplates
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Defmodule.Lazy">
            <summary> Call the method with true to turn on lazy agenda. Call with
            false to turn it off.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Exception.ConversionException">
            <summary> conversion exception is used to handle conversion of strings to
            numbers and booleans.
            </summary>
            <author>  Peter Lin
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ConversionException.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ConversionException.#ctor(System.String)">
            <param name="">message
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ConversionException.#ctor(System.Exception)">
            <param name="">cause
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.ConversionException.#ctor(System.String,System.Exception)">
            <param name="">message
            </param>
            <param name="">cause
            
            </param>
        </member>
        <member name="T:Creshendo.Resources.CreshendoResource">
            <summary>
            A strongly-typed resource class, for looking up localized strings, formatting them, etc.
            </summary>
        </member>
        <member name="P:Creshendo.Resources.CreshendoResource.ResourceManager">
            <summary>
            Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Creshendo.Resources.CreshendoResource.Culture">
            <summary>
            Overrides the current thread's CurrentUICulture property for all
            resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Creshendo.Resources.CreshendoResource.CompilerProperties_assert_on_Add">
            <summary>
            Looks up a localized string similar to 'true'.
            </summary>
        </member>
        <member name="P:Creshendo.Resources.CreshendoResource.CompilerProperties_function_not_found">
            <summary>
            Looks up a localized string similar to 'Function nto found'.
            </summary>
        </member>
        <member name="P:Creshendo.Resources.CreshendoResource.CompilerProperties_invalid_function">
            <summary>
            Looks up a localized string similar to 'Invalid Function'.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.UnDefruleFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.UnDefruleFunction.Parameter">
            <summary> The expected parameter is a single ValueParam containing a deftemplate
            instance. The function gets the deftemplate using Parameter.getValue().
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.TemporalHashedAlphaMem">
            <author>  Peter Lin
            *
            TemporalHashedAlphaMem is the hashed alpha memory for Temporal nodes.
            We use a linkedHashMap so that we can easily Remove the expired facts.
            This means at the top of the list are older facts and the bottom has
            the newer facts. We only need to Remove facts that are older than the
            current timestamp - time window. The equal would be this.
            
            if ( (currentTime - time window) > fact.timestamp )
            
            Rather than keep a timestamp of when the fact entered the join node,
            we assume the elapsed time between the time the fact entered the
            engine and when it activated the node is less than 1 second. Keeping
            a timestamp of when the fact activated the node is too costly and
            isn't practical. This means for each fact, there would be n timestamps,
            where n is the number of temporal nodes for the given object type.
            
            If we look at the number of temporal node timestamps the engine
            would need to maintain would be this.
            
            f * n = number of temporal timestamps
            
            f = number of facts
            n = number of temporal nodes
            
            If we have 100,000 facts and 100 temporal nodes, the engine would
            maintain 10,000,000 timestamps. clearly that isn't scalable and
            would have a significant impact.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.#ctor(System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.addPartialMatch(Creshendo.Util.Rete.IHashIndex,Creshendo.Util.Rete.IFact)">
            <summary> addPartialMatch stores the fact with the factId as the
            key.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.clear">
            <summary> Clear the memory.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.removePartialMatch(Creshendo.Util.Rete.IHashIndex,Creshendo.Util.Rete.IFact)">
            <summary> Remove a partial match from the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.size">
            <summary> Return the number of memories of all hash buckets
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.iterator(Creshendo.Util.Rete.IHashIndex)">
            <summary> Return an GetEnumerator of the values
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.TemporalHashedAlphaMem.iterateAll">
            <summary> return an List with all the facts
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.Subtract">
            <author>  Peter Lin
            *
            Subtract will subtract one or more numeric values. for example:
            (- 100 12 4 32)
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Subtract.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.StringCompareFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.StringCompareFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ResetFunction">
            <author>  Peter Lin
            *
            Reset will reset all deffacts and objects. To reset just the objects,
            call reset-objects
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ResetFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.ResetFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> current implementation will call Rete.resetAll. This means it
            will reset all objects and deffacts.
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ResetFunction.ReturnType">
            <summary> the function does not return anything
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ResetFunction.Parameter">
            <summary> reset does not take any parameters
            </summary>
        </member>
        <member name="T:Creshendo.Util.Parser.IParser">
            <author>  Peter Lin
            *
            Parser is a simple interface defining the basic parser operation
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Parser.IParser.parse">
            <summary> Method is meant for cases where the system is parsing an
            external file.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Parser.IParser.parse(System.Object)">
            <summary> Method is meant to parse a discrete amount of input. The
            method takes Object input. It is up to the implementing
            class to determine if the input is raw text, inputstream or
            some other wrapper.
            </summary>
            <param name="">input
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.NotFunction">
            <author>  Nikolaus Koemm
            
            Min returns the smallest of two or more values.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.NotFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.LoadFunctionGroupFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.LoadFunctionGroupFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.LessOrEqual">
            <author>  Peter Lin
            
            LessOrEqual will compare 2 or more numeric values and return true if the (n-1)th
            value is less or equal to the nth value.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.LessOrEqual.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.FunctionParam">
            <author>  Peter Lin
            *
            FunctionParam is a parameter which gets a value from a nested
            function call. As a general rule, a function parameter may need
            to assert/modify/retract facts; therefore the default constructor
            takes Rete. This can happen when a user writes a test pattern
            like (test (> 10 (* .5 ?var) ) ) .
            In the example above, the test would first multiple the bound
            variable with .5. The product is then compared to 10. At runtime,
            the TestNode would pass the necessary fact to a function that
            uses a bound variable.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.FunctionParam.func">
            <summary> The function to call
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.FunctionParam.#ctor(Creshendo.Functions.IFunction,Creshendo.Util.Rete.Rete)">
            <summary> The constructor takes a parameter
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.FunctionParam.initParams">
            <summary> 
            *
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.FunctionParam.reset">
            <summary> reset the function and set the references to the facts
            to null
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.FunctionParam.ValueType">
            <summary> Return the return value type.
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.FunctionParam.Value">
            <summary> getValue() should trigger the function 
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.FunctionParam.Facts">
            <summary> 
            </summary>
            <param name="">facts
            
            </param>
        </member>
        <member name="T:Creshendo.Util.FactUtils">
            <author>  Peter Lin
            
            the class Contains utilities for doing things like sortig the facts for
            printing.
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.ExistNeqJoin">
            <author>  Peter Lin
            
            ExistJoin is implemented differently than how CLIPS does it. According
            to CLIPS beginners guide, Exist is convert to (not (not (blah) ) ).
            Rather than do that, I'm experimenting with a specialized Existjoin
            node instead. The benefit is reduce memory and fewer nodes in the 
            network. 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft takes an array of facts. Since the Current join may be
            joining against one or more objects, we need to pass all
            previously matched facts.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an
            Alpha node.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retracting from the left is different than retractRight for couple
            of reasons.
            <ul>
            <li> NotJoin will only propogate the facts from the left</li>
            <li> NotJoin never needs to merge the left and right</li>
            </ul>
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.evaluate(Creshendo.Util.Rete.IFact[],Creshendo.Util.Rete.IFact)">
            <summary> Method will use the right binding to perform the evaluation
            of the join. Since we are building joins similar to how
            CLIPS and other rule engines handle it, it means 95% of the
            time the right fact list only has 1 fact.
            </summary>
            <param name="">leftlist
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.ToString">
            <summary> simple implementation for toString. may need to change the format
            later so it looks nicer.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistNeqJoin.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Functions.Math.Evenp">
            <author>  Nikolaus Koemm
            
            If its ony argument is even, Evenp returns true.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Evenp.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Strategies.DepthStrategy">
            <author>  Peter Lin
            *
            Depth strategy is very similar to CLIPS depth strategy. The design
            of Strategies in Sumatra is inspired by CLIPS, but the implementation
            is quite different. In CLIPS, there's isn't really an interface and
            there isn't the concept of lazy comparison. Since Sumatra uses these
            concepts, the design and implementation is quite different.
            Depth strategy is often referred to as LIFO (Last In First Out). In
            rule engines like CLIPS that propogate in assertion order, the facts
            that were asserted earlier will propogate down the network before
            newer facts. In Sumatra, HashMaps are used, which means fact
            propogation is not gauranteed to follow assertion order. It's bad
            idea to rely on assertion order for proper rule functioning. This
            is especially true of real-time systems where facts change rapidly
            in non-deterministic ways. Rules should be written such that assertion
            order is not critical. In other words, regardless of the sequence the
            facts are asserted, the correct result is produced.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.DepthStrategy.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.DepthStrategy.addActivation(Creshendo.Util.Rete.IActivationList,Creshendo.Util.Rete.IActivation)">
            <summary> Current implementation will check which order the list is and call
            the appropriate method
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.DepthStrategy.nextActivation(Creshendo.Util.Rete.IActivationList)">
            <summary> Current implementation will check which order the list is and call
            the appropriate method
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.DepthStrategy.compare(Creshendo.Util.Rete.IActivation,Creshendo.Util.Rete.IActivation)">
            <summary> The method first compares the salience. If the salience is equal,
            we then compare the aggregate time.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.DeftemplateFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.DeftemplateFunction.Parameter">
            <summary> The expected parameter is a single ValueParam containing a deftemplate
            instance. The function gets the deftemplate using Parameter.getValue().
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.DefaultReturnVector">
            <author>  Peter Lin
            *
            Basic implementation of ReturnVector used by functions to return
            the results.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultReturnVector.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultReturnVector.size">
            <summary> Current implementation returns the Count of the Vector
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultReturnVector.firstReturnValue">
            <summary> Return the first item in the vector
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.DefaultReturnVector.Iterator">
            <summary> the implementation returns itself, since ReturnVector extends
            IEnumerator interface.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.CompileMessageEventArgs">
            <author>  Peter Lin
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.CompileMessageEventArgs.#ctor(System.Object,Creshendo.Util.Rete.EventType)">
            <summary>
            Initializes a new instance of the <see cref="T:Creshendo.Util.Rete.CompileMessageEventArgs"/> class.
            </summary>
            <param name="source">The source.</param>
            <param name="eventType">Type of the event.</param>
        </member>
        <member name="T:Creshendo.Util.Rete.BoundParam">
            <author>  Peter Lin
            *
            BoundParam is a parameter that is a binding. The test node will need to
            call setFact(Fact[] facts) so the parameter can access the value.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.actionType">
            <summary> By default the action is assert
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.column">
            <summary> Column refers to the column of the fact. the value of the column
            should be a non-negative integer.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.fact">
            <summary> The fact
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.isMultislot_Renamed_Field">
            <summary> if the binding is for a multislot, it should be
            set to true. by default, it is false.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.rowId">
            <summary> the row id of the fact as defined by the rule
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.valueType">
            <summary> the int value defining the valueType
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.BoundParam.variableName">
            <summary> the name of the variable
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BoundParam.#ctor(System.Int32,System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BoundParam.getValue(Creshendo.Util.Rete.Rete,System.Int32)">
            <summary> method will try to resolve the variable and return the value.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.BoundParam.reset">
            <summary> reset sets the Fact handle to null
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.ValueType">
            <summary> Get the value type
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.Value">
            <summary> Get the value of the given slot
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.Fact">
            <summary> Return the fact
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.Facts">
            <summary>
            The TestNode should call this method to set the fact. The fact should
            never be null, since it has to have matched preceding patterns. We
            may be able to Remove the check for null. If the row id is less than
            zero, it means the binding is an object binding.
            </summary>
            <value>The facts.</value>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.ObjectRef">
            <summary> The method will return the Object instance for the given shadow fact
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.ObjectBinding">
            <summary>
            if the binding is bound to an object, the method will return true.
            By default, the method will return false.
            </summary>
            <value></value>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.Multislot">
            <summary> if the binding is for a multislot, it will return true.
            by default is is false.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.IsMultislot">
            <summary>
            only set the multislot to true if the slot is defined
            as a multislot
            </summary>
            <value>
            	<c>true</c> if this instance is multislot; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Creshendo.Util.Rete.BoundParam.ActionType">
            <summary>
            In some cases, we need to know what the action for the parameter.
            </summary>
            <value>The type of the action.</value>
            <returns>
            </returns>
        </member>
        <member name="T:Creshendo.Util.Parser.Clips2.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.kind">
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.cs.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.beginLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.beginColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.endLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.endColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.image">
            The string image of the token.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.next">
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
        </member>
        <member name="F:Creshendo.Util.Parser.Clips2.Token.specialToken">
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.Token.ToString">
            Returns the image.
        </member>
        <member name="M:Creshendo.Util.Parser.Clips2.Token.NewToken(System.Int32)">
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simlpy add something like :
            
                case MyParserConstants.ID : return new IDToken();
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use it in your lexical actions.
        </member>
        <member name="T:Creshendo.Util.Rete.TemporalFact_Fields">
            <summary> TemporalFact is an extension which supports the concepts mentioned by
            karl. The extension adds the following concepts.
            1. expire - expiration time
            2. source - URL
            3. service type - method used to obtain the fact
            4. validity - probability of the facts validity
            These ideas are useful for semantic web, agents, temporal systems and
            services.
            </summary>
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.Math.Rint">
            <author>  Nikolaus Koemm
            
            Rint returns the double value closest to the argument.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Rint.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.NodeUtils.getLeftValues(Creshendo.Util.Rete.Binding[],Creshendo.Util.Rete.IFact[])">
            <summary> Get the values from the left side for nodes that do not have
            joins with !=
            </summary>
            <param name="">facts
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.NodeUtils.getRightValues(Creshendo.Util.Rete.Binding[],Creshendo.Util.Rete.IFact)">
            <summary> convienance method for getting the values based on the bindings
            for nodes that do not have !=
            </summary>
            <param name="">ft
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.NodeUtils.getRightBindValues(Creshendo.Util.Rete.Binding[],Creshendo.Util.Rete.IFact)">
            <summary> convienance method for getting the values based on the
            bindings
            </summary>
            <param name="">ft
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.NodeUtils.getLeftBindValues(Creshendo.Util.Rete.Binding[],Creshendo.Util.Rete.IFact[])">
            <summary> Get the values from the left side
            </summary>
            <param name="">facts
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.Math.Log">
            <author>  Nikolaus Koemm
            
            Log returns the natural logarithm of a double value.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Log.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.LiteralConstraint">
            <author>  Peter Lin
            *
            Literal constraint is a comparison between an object field and a concrete
            value. for example, account.name is equal to "Peter Lin". I originally,
            named the class something else, but since CLIPS uses literal constraint,
            I decided to change the name of the class. Even though I don't like the
            term literal constraint, it doesn't make sense to fight existing
            terminology.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.LiteralConstraint.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.LiteralConstraint.Negated">
            <summary> if the literal constraint is negated, the method returns true
            </summary>
            <returns>
            
            </returns>
            <summary> if the literal constraint is negated with a "~" tilda, call
            the method pass true.
            </summary>
            <param name="">negate
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rule.LiteralConstraint.Name">
            <summary> the name is the slot name
            </summary>
            <summary> set the slot name as declared in the rule
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rule.LiteralConstraint.Value">
            <summary> Set the value of the constraint. It should be a concrete value and
            not a binding.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ListDirectoryFunction">
            <summary> ListDirectory will print out the files and folders in a given
            directory. It's the same as dir in DOS and ls in unix.
            </summary>
            <author>  pete
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ListDirectoryFunction.toPPString(Creshendo.Util.Rete.IParameter[],System.Int32)">
            <summary> for now, just return the simple form. need to implement the method
            completely.
            </summary>
        </member>
        <member name="T:Creshendo.Functions.LazyAgendaFunction">
            <author>  Peter Lin
            
            LazyAgenda is used to turn on/off lazy agenda. That means the
            activations are not sorted when added to the agenda. Instead,
            it's sorted when they are removed.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.LazyAgendaFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Messagerouter.LanguageNotSupportedException">
            <summary> An Exception that is thrown whenever the specified language is not supported by
            the MessageRouter.
            
            </summary>
            <author>  Alexander Wilden, Christoph Emonds, Sebastian Reinartz
            
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.IOFunctions">
            <author>  Peter Lin
            *
            IO Functions will initialize the IO related functions like printout,
            batch, etc.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.IOFunctions.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rule.Util.GenerateFacts">
            <author>  Peter Lin
            
            The class will generate the trigger facts for a single rule. The purpose of this is to make
            it easier to test a rule. Since a rule knows what conditions it needs, it makes sense to
            generate the trigger facts instead of doing it manually.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.Util.GenerateFacts.generateJavaFacts(Creshendo.Util.Rule.ObjectCondition,Creshendo.Util.Rete.Deftemplate,Creshendo.Util.Rete.Rete)">
            <summary> The method uses Defclass, Class, Deftemplate and Rete to create a new
            instance of the java object. Once the instance is created, the method
            uses Defclass to look up the write method and calls it with the
            appropriate value.
            </summary>
            <param name="">cond
            </param>
            <param name="">templ
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rule.Util.GenerateFacts.generateDeffact(Creshendo.Util.Rule.ObjectCondition,Creshendo.Util.Rete.Deftemplate,Creshendo.Util.Rete.Rete)">
            <summary> 
            </summary>
            <param name="">cond
            </param>
            <param name="">templ
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.Deftemplate">
            <author>  Peter Lin Deftemplate is equivalent to CLIPS deftemplate<br/>
            
            Deftemplate Contains an array of slots that represent un-ordered facts.
            Currently, deftemplate does not have a reference to the corresponding Defclass,
            since many objects in java.beans and java.lang.reflect are not serializable.
            This means when ever we need to lookup the defclass from the deftemplate, we
            have to use the String form and do the lookup.
            
            Some general design notes about the current implementation. In the case where
            a class is declared to create the deftemplate, the order of the slots are
            based on java Introspection. In the case where an user declares the
            deftemplate from console or directly, the order is the same as the string
            equivalent. The current implementation does not address redeclaring a
            deftemplate for a couple of reasons. The primary one is how does it affect
            the existing RETE nodes. One possible approach is to always Add new slots to
            the end of the deftemplate and ignore the explicit order. Another is to
            recompute the deftemplate, binds and all nodes. The second approach is very
            costly and would make redeclaring a deftemplate undesirable.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.Deftemplate.defclass">
            <summary> Defclass and Deftemplate are decoupled, so it uses a string
            to look up the Defclass rather than have a link to it. This
            is because the reflection classes are not serializable.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.getSlot(System.String)">
            <summary> A convienance method for finding the slot matching the String name.
            
            </summary>
            <param name="">name
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.getSlot(System.Int32)">
            <summary> Get the Slot at the given column id
            
            </summary>
            <param name="">id
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.getColumnIndex(System.String)">
            <summary> Look up the column index of the slot
            
            </summary>
            <param name="">name
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.createFact(System.Object,Creshendo.Util.Rete.Defclass,System.Int64)">
            <summary> Method will create a Fact from the given object instance
            
            </summary>
            <param name="">data
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.inUse">
            <summary> If any slot has a usecount greater than 0, we return true.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.toString">
            <summary> Method will return a string format with the int type code for the slot
            type
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.toPPString">
            <summary> Method will generate a pretty printer format of the Deftemplate
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.checkName(Creshendo.Util.Rete.Rete)">
            <summary> checkName will see if the user defined the module to declare the
            template. if it is, it will create the module and return it.
            
            </summary>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.incrementColumnUseCount(System.String)">
            <summary> convienance method for incrementing the column's use count.
            </summary>
            <param name="">name
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.createFact(System.Collections.IList,System.Int64)">
            <summary> Method takes a list of Slots and creates a deffact from it.
            
            </summary>
            <param name="">data
            </param>
            <param name="">id
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.cloneAllSlots">
            <summary> clone the slots
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Deftemplate.cloneDeftemplate">
            <summary> TODO - need to finish implementing this
            </summary>
        </member>
        <member name="P:Creshendo.Util.Rete.Deftemplate.Watch">
            <summary> return whether the deftemplate should be watched
            
            </summary>
            <returns>
            
            </returns>
            <summary> set whether the deftemplate should be watched
            
            </summary>
            <param name="">watch
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Deftemplate.Name">
            <summary> the template name is an alias for an object
            
            </summary>
            <param name="">name
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.Deftemplate.ClassName">
            <summary> Get the class the deftemplate represents
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Deftemplate.NumberOfSlots">
            <summary> Return the number of slots in the deftemplate
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Deftemplate.AllSlots">
            <summary> Return all the slots
            
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.DefmoduleFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.DefmoduleFunction.Parameter">
            <summary> The expected parameter is a single ValueParam containing a deftemplate
            instance. The function gets the deftemplate using Parameter.getValue().
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Defclass">
            <summary> Defclass Contains the introspection information for a single object type.
            It takes a class and uses java introspection to Get a list of the Get/set
            attributes. It also checks to see if the class implements java beans
            propertyChangeListener support. If it does, the Method object for those
            two are cached.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.#ctor(System.Type)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.init">
            <summary> init is responsible for checking the class to make sure
            it implements addPropertyChangeListener(java.beans.PropertyChangeListener)
            and removePropertyChangeListener(java.beans.PropertyChangeListener).
            We don't require the classes extend PropertyChangeSupport.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.checkBean">
            <summary> method checks to see if the class implements addPropertyChangeListener
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.getUtilMethods">
            <summary> method will try to look up Add and Remove property change listener.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.checkParameter(System.Reflection.MethodInfo)">
            <summary>
            Method checks the MethodDescriptor to make sure it only
            has 1 parameter and that it is a propertyChangeListener
            </summary>
            <param name="desc">The desc.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.getSlotValue(System.Int32,System.Object)">
            <summary>
            Note: haven't decided if the method should throw an exception
            or not. Assuming the class has been declared and the defclass
            exists for it, it normally shouldn't encounter an exception.
            Cases where it would is if the method is not public. We should
            do that at declaration time and not runtime.
            </summary>
            <param name="col">The col.</param>
            <param name="data">The data.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.createDeftemplate(System.String)">
            <summary>
            create the deftemplate for the defclass
            </summary>
            <param name="tempName">Name of the temp.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.createDeftemplate(System.String,Creshendo.Util.Rete.ITemplate)">
            <summary>
            Create the Deftemplate for the class, but with a given parent. If a
            template has a parent, only call this method. If the other method is
            called, the template is not gauranteed to work correctly.
            </summary>
            <param name="tempName">Name of the temp.</param>
            <param name="parent">The parent.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.reOrderDescriptors(Creshendo.Util.Rete.ITemplate)">
            <summary>
            the purpose of this method is to re-order the PropertyDescriptors, so
            that template inheritance works correctly.
            </summary>
            <param name="parent">The parent.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.getDescriptor(System.String)">
            <summary>
            Find the PropertyDescriptor with the same name
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.getWriteMethod(System.String)">
            <summary>
            Return the write method using slot name for the key
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.getReadMethod(System.String)">
            <summary>
            Return the read method using the slot name for the key
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Defclass.cloneDefclass">
            <summary> Method will make a copy and return it. When a copy is made, the 
            Method classes are not cloned. Instead, just the HashMap is cloned.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Defclass.JavaBean">
            <summary> If the class has a method for adding propertyChangeListener,
            the method return true.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Defclass.PropertyDescriptors">
            <summary> Return the PropertyDescriptors for the class
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Defclass.BeanInfo">
            <summary> Get the BeanInfo for the class
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Defclass.AddListenerMethod">
            <summary> Get the addPropertyChangeListener(PropertyChangeListener) method for
            the class.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.Defclass.RemoveListenerMethod">
            <summary> Get the removePropertyChangeListener(PropertyChangeListener) method for
            the class.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rete.Exception.CompileRuleException">
            <author>  Peter Lin
            *
            TODO To change the template for this generated type comment go to
            Window - Preferences - Java - Code Style - Code Templates
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.CompileRuleException.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.CompileRuleException.#ctor(System.String)">
            <param name="">message
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.CompileRuleException.#ctor(System.String,System.Exception)">
            <param name="">message
            </param>
            <param name="">cause
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.Exception.CompileRuleException.#ctor(System.Exception)">
            <param name="">cause
            
            </param>
        </member>
        <member name="T:Creshendo.Util.Rete.AlphaNode">
            <author>  Peter Lin
            *
            AlphaNode is a single input node. The design is influenced by CLIPS
            PatternNode and PartialMatch. I've tried to stay as close to CLIPS
            design as practical. A obvious difference between CLIPS and this
            implementation is the lack of memory allocation or passing pointers.<br/>
            <br/>
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.AlphaNode.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> the implementation will first check to see if the fact already matched.
            If it did, the fact stops and doesn't go any further. If it doesn't,
            it will attempt to evaluate it and Add the fact if it matches.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract a fact from the node
            
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.evaluate(Creshendo.Util.Rete.IFact)">
            <summary> evaluate the node's value against the slot's value. The method
            uses Evaluate class to perform the evaluation
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.ToString">
            <summary> Method returns the string format of the node's condition. later on
            this should be cleaned up.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.hashString">
            <summary> Method returns a hash string for ObjectTypeNode. The format is
            slotName:operator:value
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaNode.toPPString">
            <summary> Method returns the pretty printer formatted string of the node's
            condition. For now, the method just replaces the operator. It might
            be nice to replace the slot id with the slot name.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNode.Operator">
            <summary> Set the operator using the int value
            </summary>
            <param name="">opr
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNode.Shared">
            <summary> the first time the RETE compiler makes the node shared,
            it needs to increment the useCount.
            </summary>
            <param name="">share
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNode.Slot">
            <summary> Set the slot id. The slot id is the deftemplate slot id
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.AlphaNode.UseCount">
            <summary> return the times the node is shared
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.Math.Round">
            <author>  Nikolaus Koemm
            
            Round returns the closest int to the argument.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Round.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.RightMatchesFunction">
            <author>  Peter Lin
            The purpose of RightMatches is to print out the facts in the right
            side of BetaNodes. It isn't the same as matches function. Unlike
            matches, RightMatches prints out all the facts on the right side
            and doesn't show which facts it matches on the left.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.RightMatchesFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ResetObjectsFunction">
            <author>  Peter Lin
            *
            Reset the objects means retract all the objects and assert
            them again.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ResetObjectsFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.IQuery">
              Peter Lin
            
            Query interface is designed to execute queries to external
            data sources. The design of the interface expects the system will
            attempt to load an object matching the given parameters.
            
            
        </member>
        <member name="M:Creshendo.Util.Rete.IQuery.executeQuery(Creshendo.Util.Rete.ITemplate,Creshendo.Util.Rete.Slot[])">
            <summary> Since the query is triggered by backward chaining nodes, the
            method takes the template name, slot name and values.
            </summary>
            <param name="">template
            </param>
            <param name="">params
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.IQuery.supportedTemplates">
            <summary> Query adapters that implement the method need to declare which
            classes it supports.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rule.MultiValue">
            <author>  Peter Lin
            The purpose of the class is for conditions that have  or |. For
            
            In those cases, we don't want to create a Literal constraint, since
            they are all for the same slot.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.MultiValue.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ModifyFunction">
            <author>  Peter Lin
            *
            ModifyFunction is equivalent to CLIPS modify function.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ModifyFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.ModifyFunction.convertToSlots(Creshendo.Util.Rete.IParameter[],Creshendo.Util.Rete.Deftemplate)">
            <summary> convert the SlotParam to Slot objects
            </summary>
            <param name="">params
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Functions.ModifyFunction.Parameter">
            <summary> The current implementation expects 3 parameters in the following
            sequence:<br/>
            BoundParam
            SlotParam[]
            <br/>
            Example: (modify ?boundVariable (slotName value)* )
            </summary>
        </member>
        <member name="T:Creshendo.Functions.LoadFunctionsFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Util.IOUtilities">
            <summary> IOUtilities Contains some commonly used static methods for saving and
            loading files.
            </summary>
            <author>  Peter
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.HashedNeqAlphaMemory">
            <author>  Peter Lin
            HashedAlphaMemory2 is different in that it has 2 levels of
            indexing. The first handles equal to comparisons. The second
            level handles not equal to.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.#ctor(System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.addPartialMatch(Creshendo.Util.Rete.NotEqHashIndex,Creshendo.Util.Rete.IFact)">
            <summary> addPartialMatch stores the fact with the factId as the
            key.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.clear">
            <summary> Clear the memory.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.removePartialMatch(Creshendo.Util.Rete.NotEqHashIndex,Creshendo.Util.Rete.IFact)">
            <summary> Remove a partial match from the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.size">
            <summary> Return the number of memories of all hash buckets
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.iterator(Creshendo.Util.Rete.NotEqHashIndex)">
            <summary> Return an GetEnumerator of the values
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.zeroMatch(Creshendo.Util.Rete.NotEqHashIndex)">
            <summary>
            if there are zero matches for the NotEqHashIndex2, the method
            return true. If there are matches, the method returns false.
            False means there's 1 or more matches
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.HashedNeqAlphaMemory.iterateAll">
            <summary> return an List with all the facts
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.DefruleFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.DefruleFunction.Parameter">
            <summary> the input parameter is a single ValueParam containing a Defrule
            instance.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.DefaultWM">
            <author>  Peter Lin
            *
            This a new implementation of the working memory that is a clean rewrite to make
            it organized. The old one was getting a bit messy and refactoring it was becoming
            a pain.
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.DefaultWM.deffactMap">
            <summary> We use a HashMap to make it easy to determine if an existing deffact
            already exists in the working memory. this is only used for deffacts and
            not for objects
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.DefaultWM.defglobals">
            <summary> Container for Defglobals
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.DefaultWM.dynamicFacts">
            <summary> We keep a map of the dynamic object instances. When the rule engine is
            notified
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.DefaultWM.initialFacts">
            <summary> The initial facts the rule engine needs at startup
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.DefaultWM.modules">
            <summary> The org.jamocha.rete.util.List for the modules.
            </summary>
        </member>
        <member name="F:Creshendo.Util.Rete.DefaultWM.staticFacts">
            <summary> We keep a map between the object instance and the corresponding shadown
            fact. If an object is added as static, it is added to this map. When the
            rule engine is notified of changes, it will check this list. If the
            object instance is in this list, we ignore it.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.assertObject(System.Object,System.String,System.Boolean,System.Boolean)">
            <summary>
            The current implementation of assertObject is simple, but flexible. This
            version is not multi-threaded and doesn't use an event queue. Later on a
            multi-threaded version will be written which overrides the base
            implementation. If the user passes a specific template name, the engine
            will attempt to only propogate the fact down that template. if no
            template name is given, the engine will propogate the fact down all input
            nodes, including parent templates.
            </summary>
            <param name="data">The data.</param>
            <param name="template">The template.</param>
            <param name="statc">if set to <c>true</c> [statc].</param>
            <param name="shadow">if set to <c>true</c> [shadow].</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.assertObjects(System.Collections.IList)">
            <summary>
            By default assertObjects will assert with shadow and dynamic. It also
            assumes the classes aren't using an user defined template name.
            </summary>
            <param name="objs">The objs.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.clearFacts">
            <summary> Clear the deffacts from the working memory. This does not include facts
            asserted using assertObject.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.clearObjects">
            <summary> Clear the objects from the working memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.getAlphaMemory(System.Object)">
            <summary> The current implementation will try to find the memory for the node.
            If it doesn't find it, it will create a new one.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.getBetaLeftMemory(System.Object)">
            <summary> the current implementation will try to find the memory for the node.
            If it doesn't find it, it will create a new Left memory, which is
            HashMap.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.getBetaRightMemory(System.Object)">
            <summary> the current implementation will try to find the memory for the node.
            If it doesn't find it, it checks the node type and creates the
            appropriate AlphaMemory for the node. Since right memories are
            hashed, it creates the appropriate type of Hashed memory.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.modifyObject(System.Object)">
            <summary>
            Modify will call retract with the old fact, followed by updating the fact
            instance and asserting the fact.
            </summary>
            <param name="data">The data.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.printWorkingMemory(Creshendo.Util.Collections.IGenericMap{System.Object,System.Object})">
            <summary> TODO - not implemented yet
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.retractObject(System.Object)">
            <summary>
            Retracts the object.
            </summary>
            <param name="data">The data.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.createFact(System.Object,Creshendo.Util.Rete.Defclass,System.String,System.Int64)">
            <summary>
            The implementation will look in the current module in focus. If it isn't
            found, it will search the other modules. The last module it checks should
            be the main module.
            </summary>
            <param name="data">The data.</param>
            <param name="dclass">The dclass.</param>
            <param name="template">The template.</param>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.createNSFact(System.Object,Creshendo.Util.Rete.Defclass,System.Int64)">
            <summary>
            convienance method for creating a Non-Shadow fact.
            </summary>
            <param name="data">The data.</param>
            <param name="dclass">The dclass.</param>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.assertFactWProfile(Creshendo.Util.Rete.Deffact)">
            ----- helper methods that are not defined in WorkingMemory interface ----- ///
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.printWorkingMemory(Creshendo.Util.Rule.IRule)">
            <summary>
            Printout the memory for the given rule.
            </summary>
            <param name="rule">The rule.</param>
        </member>
        <member name="M:Creshendo.Util.Rete.DefaultWM.retractFactWProfile(Creshendo.Util.Rete.Deffact)">
            <summary>
            Retracts the fact W profile.
            </summary>
            <param name="fact">The fact.</param>
        </member>
        <member name="P:Creshendo.Util.Rete.DefaultWM.Strategy">
            <summary> the implementation sets the strategy for the current module
            in focus. If there are multiple modules, it does not set
            the strategy for the other modules.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Compiler.CompilerProvider">
            <summary> 
            </summary>
            <author>  HouZhanbin
            Oct 12, 2007 10:24:19 AM
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Util.Rete.AlphaMemoryImpl">
            <author>  Peter Lin
            *
            Basic implementation of Alpha memory. It uses HashMap for storing
            the indexes.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaMemoryImpl.#ctor(System.String)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaMemoryImpl.addPartialMatch(Creshendo.Util.Rete.IFact)">
            <summary> addPartialMatch stores the fact with the factId as the
            key.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaMemoryImpl.clear">
            <summary> Clear the memory.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaMemoryImpl.removePartialMatch(Creshendo.Util.Rete.IFact)">
            <summary> Remove a partial match from the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaMemoryImpl.size">
            <summary> Return the Count of the memory
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.AlphaMemoryImpl.GetEnumerator">
            <summary> Return an GetEnumerator of the values
            </summary>
        </member>
        <member name="T:Creshendo.Functions.WatchFunction">
            <author>  Peter Lin
            
            WatchFunction allows users to watch different engine processes, like
            activations, facts and rules.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.WatchFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.IValue">
            <author>  pete
            *
            
            </author>
        </member>
        <member name="T:Creshendo.Functions.UsageFunction">
            <author>  Karl-Heinz Krempels
            
            </author>
            <returns> a short usage for a function name passed as argument.
            
            </returns>
            <param name="the">name of a function.
            
            </param>
        </member>
        <member name="M:Creshendo.Functions.UsageFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ShellFunction">
            <author>  Peter Lin
            *
            The purpose of Shell function is to make it easy to parse text in the shell
            and execute the real function. ShellFunction expects the parser to pass
            the name of the real function and parameter values.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ShellFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="P:Creshendo.Functions.ShellFunction.Name">
            <summary>
            The name of the function to call
            </summary>
            <value></value>
            <returns>
            </returns>
        </member>
        <member name="T:Creshendo.Util.Rule.OrCondition">
            <author>  Peter Lin
            *
            AndCondition is specifically created to handle and conjunctions. AndConditions
            are compiled to a BetaNode.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rule.OrCondition.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.OrCondition.addNode(Creshendo.Util.Rete.BaseNode)">
            <summary> not implemented yet
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rule.OrCondition.addNewAlphaNodes(Creshendo.Util.Rete.BaseNode)">
            <summary> not implemented yet
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.NoMemANode">
            <author>  Peter Lin
            *
            NoMemAlphaNode has no memory. It is different than the normal
            AlphaNode in that asserts and retract always propogate. this means
            retract performance is a lot slower than AlphaNode.<br/>
            <br/>
            
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Rete.NoMemANode.slot">
            <summary> The use of Slot(s) is similar to CLIPS design
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.#ctor(System.Int32)">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.assertFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> 
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.retractFact(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract a fact from the node
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.evaluate(Creshendo.Util.Rete.IFact)">
            <summary> evaluate the node's value against the slot's value. The method
            uses Evaluate class to perform the evaluation
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.ToString">
            <summary> Method returns the string format of the node's condition. later on
            this should be cleaned up.
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.hashString">
            <summary> Method returns a hash string for ObjectTypeNode. The format is
            slotName:operator:value
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.NoMemANode.toPPString">
            <summary> Method returns the pretty printer formatted string of the node's
            condition. For now, the method just replaces the operator. It might
            be nice to replace the slot id with the slot name.
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemANode.Operator">
            <summary> Set the operator using the int value
            </summary>
            <param name="">opr
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemANode.Shared">
            <summary> the first time the RETE compiler makes the node shared,
            it needs to increment the useCount.
            </summary>
            <param name="">share
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemANode.Slot">
            <summary> Set the slot id. The slot id is the deftemplate slot id
            </summary>
            <param name="">id
            
            </param>
        </member>
        <member name="P:Creshendo.Util.Rete.NoMemANode.UseCount">
            <summary> return the times the node is shared
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="T:Creshendo.Functions.Math.Max">
            <author>  Nikolaus Koemm
            
            Max returns the greatest of two or more values.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.Math.Max.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.ListTemplatesFunction">
            <author>  Peter Lin
            
            ListTemplates will list all the templates and print them out.
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.ListTemplatesFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Functions.ListTemplatesFunction.executeFunction(Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IParameter[])">
            <summary> The current implementation will print out all the templates in
            no specific order. The function does basically the same thing
            as CLIPS (list-deftemplates)
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.InitialFact">
            <author>  Peter Lin
            
            InitialFact is used for rules without conditions and cases where a rule
            starts with exist or not.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.InitialFact.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.ExistJoinFrst">
            <author>  Peter Lin
            
            ExistJoinFrst is a special implementation for situations
            when the first Conditional Element is an Exists. The main
            difference is the left input is a dummy and doesn't do
            anything. This gets around needing an InitialFact when the
            first CE is Exists. 
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.clear(Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Clear will Clear the lists
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.assertLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> assertLeft is a dummy, since we don't need an initial
            fact or LeftInputAdapater.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.assertRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Assert from the right side is always going to be from an
            Alpha node.
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.retractLeft(Creshendo.Util.Rete.Index,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> retractLeft is a dummy and doesn't do anything
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.retractRight(Creshendo.Util.Rete.IFact,Creshendo.Util.Rete.Rete,Creshendo.Util.Rete.IWorkingMemory)">
            <summary> Retract from the right works in the following order.
            1. Remove the fact from the right memory
            2. check which left memory matched
            3. propogate the retract
            </summary>
            <param name="">factInstance
            </param>
            <param name="">engine
            
            </param>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.ToString">
            <summary> method returns string format for the node
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.ExistJoinFrst.toPPString">
            <summary> The current implementation is similar to BetaNode
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Evaluate">
            <author>  Peter Lin
            *
            The purpose of Evaluate is similar to the Evaluatn in CLIPS. The class
            constains static methods for evaluating two values
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluate(System.Int32,System.Object,System.Object)">
            <summary> evaluate is responsible for evaluating two values. The left value
            is the value in the slot. The right value is the value of the object
            instance to match against.
            </summary>
            <param name="">operator
            </param>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateEqual(System.Object,System.Object)">
            <summary> evaluate if two values are equal. If they are equal
            return true. otherwise return false.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateStringEqual(System.String,System.Object)">
            <summary> evaluate if two values are equal when left is a string and right
            is some object.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateEqual(System.Boolean,System.Object)">
            <summary> evaluate Boolean values against each other. If the right is a String,
            the method will attempt to create a new Boolean object and evaluate.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateNotEqual(System.Object,System.Object)">
            <summary> evaluate if two values are not equal. If they are not
            equal, return true. Otherwise return false.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateNotEqual(System.Boolean,System.Object)">
            <summary> evaluate Boolean values against each other. If the right is a String,
            the method will attempt to create a new Boolean object and evaluate.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateNull(System.Object,System.Object)">
            <summary> In the case of checking if an object's attribute is null,
            we only check the right.
            </summary>
            <param name="">left
            </param>
            <param name="">right
            </param>
            <returns>
            
            </returns>
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateLess(System.Int32,System.Object)">
            ------- Integer comparison methods ------- ///
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateLess(System.Int16,System.Object)">
            ------- Short comparison methods ------- ///
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateLess(System.Int64,System.Object)">
            ------- Long comparison methods ------- ///
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateLess(System.Single,System.Object)">
            ------- Float comparison methods ------- ///
        </member>
        <member name="M:Creshendo.Util.Rete.Evaluate.evaluateLess(System.Double,System.Object)">
            ------- Double comparison methods ------- ///
        </member>
        <member name="T:Creshendo.Functions.DefglobalFunction">
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="M:Creshendo.Functions.DefglobalFunction.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="T:Creshendo.Functions.DefclassFunction">
            <author>  Peter Lin
            
            
            </author>
        </member>
        <member name="P:Creshendo.Functions.DefclassFunction.Parameter">
            <summary> defclass function expects 3 parameters. (defclass classname,
            templatename, parenttemplate) parent template name is optional.
            </summary>
        </member>
        <member name="T:Creshendo.Util.Rete.Strategies.BreadthStrategy">
            <author>  Peter Lin
            *
            Breadth strategy is very similar to CLIPS breadth strategy. The design
            of Strategies in Sumatra is inspired by CLIPS, but the implementation
            is quite different. In CLIPS, there's isn't really an interface and
            there isn't the concept of lazy comparison. Since Sumatra uses these
            concepts, the design and implementation is quite different.
            Breadth strategy is often referred to as FIFO (First In First Out).
            What this means in practice is that matches with older facts will be
            executed before matches with newer facts. By executed, we mean the
            actions of the rule will be executed.
            CLIPS beginner guide provides a Clear explanation of breadth:
            5.3.2 Breadth Strategy
            Newly activated rules are placed below all rules of the same salience.
            
            </author>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.BreadthStrategy.#ctor">
            <summary> 
            </summary>
        </member>
        <member name="M:Creshendo.Util.Rete.Strategies.BreadthStrategy.compare(Creshendo.Util.Rete.IActivation,Creshendo.Util.Rete.IActivation)">
            <summary>
            The method first compares the salience. If the salience is equal,
            we then compare the aggregate time.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Creshendo.Util.Rule.Analysis_Fields">
            <summary> Validation interface defines 3 methods a basic validation component
            would need to have. Validation can occur at any time, so it can be
            used by the rule compiler, an IDE or a parser.
            
            The product of the validation is either it passes, or a summary of
            the errors and warnings.
            
            </summary>
            <author>  Peter Lin
            *
            
            </author>
        </member>
        <member name="F:Creshendo.Util.Collections.GenericHashMap`2.modCount">
            The number of times this HashMap has been structurally modified
            Structural modifications are those that change the number of mappings in
            the HashMap or otherwise modify its internal structure (e.g.,
            rehash).  This field is used to make iterators on Collection-views of
            the HashMap fail-fast.  (See ConcurrentModificationException).
        </member>
        <member name="F:Creshendo.Util.Collections.GenericHashMap`2.NULL_KEY">
            Value representing null keys inside tables.
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.#ctor(System.Int32)">
             Constructs an empty <tt>HashMap</tt> with the specified initial
             capacity and the default load factor (0.75).
            
             @param  initialCapacity the initial capacity.
             @throws IllegalArgumentException if the initial capacity is negative.
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.#ctor">
            Constructs an empty <tt>HashMap</tt> with the default initial capacity
            (16) and the default load factor (0.75).
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.unmaskNull(System.Object)">
            Returns key represented by specified internal representation.
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.init">
            Initialization hook for subclasses. This method is called
            in all constructors and pseudo-constructors (clone, readObject)
            after HashMap has been initialized but before any entries have
            been inserted.  (In the absence of this method, readObject would
            require explicit knowledge of subclasses.)
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.eq(`0,`0)">
            <summary>
            check for equality of non-null references x and possibly-null y
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.indexFor(System.Int32,System.Int32)">
            <summary>
            returns index for hash code h
            </summary>
            <param name="h"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.ContainsKey(`0)">
            <summary>
            true if this map contains a mapping for the specified key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.Put(`0,`1)">
            <summary>
            add a key value pair to this map
            </summary>
            <param name="key"></param>
            <param name="entry"></param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.RemoveEntryForKey(`0)">
            <summary>
            removes an entry for the specified key
            returns the removed entry
            </summary>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.RemoveMapping(System.Object)">
            <summary>
            remove the mapping for a specified entry
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.hash(System.Object)">
            <summary>
            generate a hash code for the specified key
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.PutForCreate(`0,`1)">
            <summary>
            used instead of Add by Constructors and Clones, does not resize the table
            calls CreateEntry instead of AddEntry
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.AddEntry(System.Int32,`0,`1,System.Int32)">
            <summary>
            add a new entry with the key, value and hashcode, to the specified bucket
            if needed this method will resize the table
            </summary>
            <param name="hash"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="bucketIndex"></param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.CreateEntry(System.Int32,`0,`1,System.Int32)">
            <summary>
            this is used when creating entries as part of a constructor or Clone call
            </summary>
            <param name="hash"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="bucketIndex"></param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.Resize(System.Int32)">
            <summary>
            rehashes the the contents of this map into a new HashMap with a larger capacity
            called automatically when the number of keys exceedts the capacity and load factor
            
            </summary>
            <param name="newCapacity">new capacity, must be a power of 2</param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.Transfer(Creshendo.Util.Collections.IHashMapEntry{`0,`1}[])">
            <summary>
            transfer all entries from current table into the newTable
            </summary>
            <param name="newTable"></param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.putAll(Creshendo.Util.Collections.IGenericMap{`0,`1})">
            <summary>
            copies all mappings from the specified map to this map
            will replace any mappings that had matching keys
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.Remove(`0)">
            <summary>
            removes the mapping for this key from this map
            </summary>
            <param name="key"></param>
            <returns>previous value for the key, or null if no mapping</returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.ContainsValue(`1)">
            <summary>
            returns true if this Map has a mapping for the object
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.ContainsNullValue">
            <summary>
            special case code for containsValue with null argument
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.Clone">
            <summary>
            return a shallow copy of the HashMap instance
            the keys and values are not cloned
            </summary>
            <returns></returns>
        </member>
        <member name="M:Creshendo.Util.Collections.GenericHashMap`2.GetEntry(`0)">
            <summary>
            reutrns the entry associated with the key
            </summary>
        </member>
        <member name="P:Creshendo.Util.Collections.GenericHashMap`2.Count">
            <summary>
            returns the number of key-value mappings
            </summary>
        </member>
        <member name="P:Creshendo.Util.Collections.GenericHashMap`2.Capacity">
            <summary>
            Get the current capacity.  Readonly
            </summary>
        </member>
        <member name="P:Creshendo.Util.Collections.GenericHashMap`2.IsEmpty">
            <summary>
            returns true if there are no key-value mappings
            </summary>
        </member>
        <member name="T:Creshendo.Util.Collections.GenericHashMap`2.HashMapEntry`2">
            <summary>
            represents an entry in the HashMap
            </summary>
            
        </member>
    </members>
</doc>
